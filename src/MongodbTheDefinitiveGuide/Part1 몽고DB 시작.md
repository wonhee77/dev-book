# Part1 몽고DB 시작

## 1장 몽고DB 소개

### 1.1 손쉬운 사용

몽고DB는 분산 확장(Scale out)을 쉽게 하기 위한 도큐먼트 지향 데이터베이스다.

내장 도큐먼트와 배열을 허용함으로써 복잡한 계층 관계를 하나의 레코드로 표현할 수 있다.

고정된 스키마가 없으므로 필요할 때마다 쉽게 필드를 추가하거나 제거할 수 있다.

### 1.2 확장 가능한 설계

몽고DB는 분산 확장을 염두에 두고 설계됐다. 도큐먼트 지향 데이터 모델이기 때문

### 1.3 다양한 기능

인덱싱

고유, 복합, 공간 정보, 전문 인덱싱 기능 제공한다.  
중첩된 도큐먼트 및 배열과 같은 계층 구조의 보조 인덱스도 지원

집계

데이터 처리 파이프라인 개념을 기반으로 한 집계 프레임워크를 제공한다.

특수한 컬렉션 유형

로그와 같은 최신 데이터를 유지하고자 세션이나 고정 크기 컬렉션과 같이 특정 시간에 만료해야하는 데이터에 대해 유효 시간 컬렉션을 지원한다. 또한 criteria filter와 일치하는 도큐먼트에 한정된 partial index를 지원함으로써 효율성을 높이고 필요한 저장 공간을 줄인다.

파일 스토리지

큰 파일과 파일 메타데이터를 편리하게 저장하는 프로토콜을 지원한다.

### 1.4 고성능

몽고DB에서는 동시성과 처리량을 극대화하기 위해 wiredTiger storage engine에 opportunistic locking을 사용했다.  
따라서 캐시처럼 제한된 용량의 램으로 쿼리에 알맞은 인덱스를 자동으로 선택할 수 있다. 몽고DB는 모든 측면에서 고성능을 유지하기 위해 설계됐다.

일부 기능의 경우 데이터베이스 서버는 처리와 로직을 클라이언트 측에 오프로드한다.

### 1.5 몽고 DB의 철학

결국 몽고 DB 프로젝트의 주 관심사는 확장성이 높으며 유연하고 빠른, 즉 완전한 기능을 갖춘 데이터 스토리지를 만드는 일이다.

## 2장 몽고DB 기본

### 2.1 도큐먼트

몽고DB의 핵심은 정렬된 키와 연결된 값의 집합으로 이뤄진 **도큐먼트**다.

데이터형과 대소문자를 구분한다.

```jsx
{"count" : 5} 와 {"count" : "5"}는 다르다
{"Count" : 5} 와 {"count" : 5}는 다르다
```

키가 중복될 수 없다.

### 2.2 컬렉션

컬렉션은 도큐먼트의 모음이다.

**2.2.1 동적 스키마**

컬렉션은 동적 스키마를 가진다. 하나의 컬렉션 내 도큐먼트들이 모두 다른 구조를 가질 수 있다.

도큐먼트들의 키, 키의 개수, 데이터형이 모두 다른데 왜 별도의 컬렉션으로 나누는 이유

- 컬렉션 별로 목록을 뽑으면 한 컬렉션 내 특정 데이터형 별로 쿼리해서 목록을 뽑을 때 보다 훨씬 빠르다.
- 같은 종류의 데이터를 하나의 컬렉션에 모아두면 데이터의 지역성이 좋다.
- 인덱스를 만들면 도큐먼트는 특정 구조를 가져야 한다. 같은 유형의 도큐먼트를 하나의 컬렉션에 넣음으로써 컬렉션을 효율적으로 인덱싱할 수 있다.

**2.2.2 네이밍**

**서브컬렉션**

서브컬렉션의 네임스페이스에 마침표 문자(.)를 사용해 컬렉션을 체계화한다.

blog.post와 blog.authors라는 컬렉션을 가질 수 있으며 이는 단지 체계화 하기 위함이며 blog 컬렉션이나 자식 컬렉션과는 아무 관계가 없다.

### 2.3 데이터베이스

몽고DB는 컬렉션에 도큐먼트를 그룹화할 뿐 아니라 데이터베이스에 컬렉션을 그룹 지어 놓는다.

몽고DB의 단일 인스턴스는 여러 데이터베이스를 호스팅할 수 있으며, 각 데이터베이스를 완전히 독립적으로 취급할 수 있다.

한 애플리케이션의 데이터를 동일한 데이터베이스에 저장하는 것도 좋은 방식이지만 데이터베이스를 나누면 하나의 몽고DB 서버에서 여러 애플리케이션이나 여러 사용자가 데이터를 저장할 때 유용하다.

데이터베이스는 컬렉션과 마찬가지로 이름으로 식별되고, UTF-8 문자열을 사용할 수 있다.

직접 접근할 수는 있지만 특별한 의미론을 갖는 예약된 데이터베이스 이름도 있다.

admin

admin 데이터 베이스는 인증과 인가 역할을 한다.

local

local 데이터베이스는 단일 서버에 대한 데이터를 저장한다. Replica set에서 local은 replication 프로세스에 사용된 데이터를 저장한다. local 데이터베이스 자체는 복제되지 않는다.

config

샤딩된 몽고DB 클러스터는 config 데이터베이스를 사용해 각 샤드의 정보를 저장한다.

### 2.4 몽고DB 시작

서버를 실행하려면 유닉스 명령행 환경에서 mongod 실행파일을 실행한다.

mongod는 인수없이 실행하면 기본 데이터 디렉터리로 /data/db를 사용한다. 데이터 디렉터리가 존재하지 않거나 쓰기 권한이 없을 때는 서버가 시작되지 않는다.

시작할 때 서버는 버전과 시스템 정보를 출력한 후 클라이언트의 연결을 기다린다.

### 2.5 몽고DB 셸 소개

몽고DB는 명령행에서 몽고DB 인스턴스와 상호작용하는 자바스크립트 셸을 제공한다.

**2.5.1 셸 실행**

mongo를 실행해 셸을 시작한다.

셸은 시작하면 자동으로 로컬 장비에서 실행 중인 몽고DB 서버에 접속을 시도한다.

셸은 완전한 자바스크립트 해석기이며 임의의 자바스크립트 프로그램을 실행한다.

**2.5.2 몽고DB 클라이언트**

셸은 시작할 때 몽고DB 서버의 test 데이터베이스에 연결하고, 데이터베이스 연결을 전역 변수 db에 할당한다. 셸에서는 주로 이 변수를 통해 몽고DB에 접근한다.

현재 db에 할당된 데이터 베이스를 확인하려면 db를 입력한다.

```jsx
> db
```

데이터베이스 선택

```jsx
> user video
switched to db video
```

**2.5.3 셸 기본 작업**

셸에서 데이터를 조작하거나 보려면 생성, 읽기, 갱신, 삭제의 네 가지 기본적인 작업을 한다.

**생성**

insertOne 함수는 컬렉션에 도큐먼트를 추가한다.

우선 도큐먼트를 나타내는 자바스크립트 객체인 movie라는 지역 변수를 생성한다.

```jsx
> movie = {"title" : "Star wars",
...}
```

이 객체는 유효한 몽고DB 도큐먼트이며 insertOne 함수를 이용해 movies 컬렉션에 저장할 수 있다.

```jsx
> db.movies.insertOne(movie)
{
		"acknowledged" : true,
		"insertedId" : ObjectId("12342134asdf")
}
```

컬렉션에 find를 호출해서 확인할 수 있다.

```jsx
> db.movies.find().pretty()
```

**읽기**

find와 findOne은 컬렉션을 쿼리하는 데 사용한다. 컬렉션에서 단일 도큐먼트를 읽으려면 findOne을 사용한다.

find와 findOne은 쿼리 도큐먼트 형태로 조건 전달도 가능하다. 셸은 20개까지 자동으로 출력하지만 그 이상도 가져올 수 있다.

**갱신**

게시물을 갱신하려면 updateOne을 사용한다. updateOne의 매개변수는 최소 두 개다. 첫 번째는 수정할 다큐먼트를 찾는 기준이고, 두 번째는 갱신 작업을 설명하는 도큐먼트다.

```jsx
> db.movies.updateOne({title : "Star Wars"},...,{$set : {reviews : []}})
```

**삭제**

deleteOne과 deleteMany는 도큐먼트를 데이터베이스에서 영구적으로 삭제한다.

두 함수 모두 필터 도큐먼트로 삭제 조건을 지정한다.

## 2.6 데이터형

### 2.6.1 기본 데이터형

몽고DB에서 도큐먼트는 자바스크립트 객체와 개념적으로 닯았다는 점에서 JSON과 닮았다 라고 생각할 수 있다.

하지만 JSON은 데이터형이 null, 불리언, 숫자, 문자열, 배열, 객체만 지원하기 때문에 표현력이 제한적이다.

날짜형도 없고, 숫자형도 한가지 타입 밖에 없다. 또한 부동소수점형과 정수형을 표현하는 방법이 없고 32비트 64비트도 구별되지 않는다. 함수나 정규표현식과 같은 흔히 쓰는 데이터형을 표현하는 방법도 없다.

몽고DB는 JSON의 키/값 성질을 유지하면서 추가적인 데이터형을 지원한다.

다음 목록은 흔히 지원되는 데이터형이 셸에서 어떻게 도큐먼트의 일부로 표현되는지 나타낸다.

| 자료형 | 설명 |
| --- | --- |
| null | null 값과 존재하지 않는 필드를 표현하는 데 사용한다. |
| boolean | 참과 거짓 값에 사용한다. |
| 숫자 | 셸은 64비트 부동소수점 수를 기본으로 사용한다. |
| 문자열 | 어떤 UTF-8 문자열이든 문자열형으로 표현할 수 있다. |
| 날짜 | 1970년 1월 1일부터의 시간을 1/1000초 단위로 나타내는 64비트 정수로 날짜를 저장한다. 표준 시간대는 저장하지 않는다. |
| 정규표현식 | 자바스크립트의 정규 표현식 문법을 사용할 수 있다. |
| 배열 | 값의 set이나 list를 배열로  표현할 수 있다. |
| 내장 도큐먼트 | 도큐먼트는 부모 도큐먼트의 값으로 내장된 도큐먼트 전체를 포함할 수 있다. |
| 객체 ID | 객체 ID는 도큐먼트용 12바이트 ID다. ObjectId() |
| 이진 데이터  | 이진 데이터는 임의의 바이트 문자열이며 셸에서는 조작이 불가능하다. |
| 쿼리 | 쿼리와 도큐먼트는 임의의 자바스크립트 코드를 포함할 수 있다. |

### 2.6.2 날짜

자바스크립트에서 Date 클래스는 몽고DB의 날짜를 표현하는 데 사용한다. 새로운 Date 객체를 생성할 때는 항상 Date()가 아닌 new Date()를 호출해야 한다. 항상 Date 생성자를 사용하도록 주의하지 않으면 문자열과 날짜가 뒤범벅된다.

### 2.6.3 배열

배열은 정렬 연산(list, stack, queue)과 비정렬 연산(set)에 호환성 있게 사용 가능한 값이다.

```jsx
{"things" : ["pie", 3.14]} // 서로 다른 데이터형을 값으로 포함할 수 있다.
```

도큐먼트 내 배열의 장점으로 몽고DB가 배열의 구조를 ‘이해한다’는 점과, 배열의 내용에 작업을 수행하기 위해 내부에 도달하는 방법을 안다는 점이 있다. 따라서 배열에 쿼리하거나 배열의 내용을 이용해 인덱스를 만들 수 있다.

앞 예제에서 몽고DB는 3.14가 “things” 배열의 요소인 모든 도큐먼트를 쿼리한다. 자주쓰는 쿼리라면 “things” 키를 인덱스로 생성하면 쿼리 속도가 향상된다.

### 2.6.4 내장 도큐먼트

도큐먼트는 키에 대한 값이 될 수 있는데 이를 내장 도큐먼트라고 한다.

배열과 마찬가지로 몽고DB는 내장 도큐먼트의 구조를 이해하고, 인덱스를 구성하고, 쿼리하며, 갱신하기 위해 내장 도큐먼트 내부에 접근한다.

하지만 몽고DB에서는 더 많은 데이터 반복이 생길 수 있다는 단점이 있다. 관계형 데이터베이스에서 테이블이 분리가 되어 있다면 분리되어 있는 테이블만 수정하면 되지만 몽고DB에서는 모든 도큐먼트를 수정해야한다.

### 2.6.5 _id와 ObjectId

몽고DB에 저장된 모든 도큐먼트는 “_id” 키를 가진다. “ObjectId”가 기본이다.

**ObjectIds**

자동 증가하는 기본 키처럼 전통적인 것이 아닌 ObjectId를 사용하는 주요 이유는 몽고DB의 분산 특성 때문이다. 여러 서버에 걸쳐 자동으로 증가하는 기본 키를 동기화하는 작업은 어렵고 시간이 걸린다. 몽고DB는 분산 데이터베이스로 설계됐기 때문에 샤딩된 환경에서 고유 식별자를 생성하는 것이 매우 중요했다.

ObjectIdsms 12바이트 스토리지를 사용하며 24자리 16진수 문자열 표현이 가능하다. 바이트당 2자리를 사용한다.

ObjectId 12바이트는 다음과 같이 생성된다.

0 타임스탬프, 1 랜덤, 2 카운터 (랜덤 시작 값), 3, 4, 5, 6, 7, 8, 10, 11

ObjectId의 첫 4바이트는 1970년 1월 1일부터의 시간을 1/1000초 단위로 저장하는 타임스탬프다.

다음 5바이트는 랜덤 값이다. 최종 3바이트는 서로 다른 시스템에서 충돌하는 ObjectId들을 생성하지 않도록 랜덤 값으로 시작하는 카운터다.

**_id 자동 생성**

도큐먼트를 입력할 때 “_id” 키를 명시하지 않으면 입력된 도큐먼트에 키가 자동으로 추가된다. 일반적으로는 클라이언트 쪽 드라이버에서 관리한다.

## 2.7  몽고DB 셸 사용

다른 장비나 포트에 mongod를 연결하려면 셸을 시작할 때 호스트명, 포트, 데이터베이스를 명시해야 한다.

```jsx
$ mongo some-host:30000/myDB
```

### 2.7.1 셸 활용 팁

help를 입력하면 셸에 내장된 도움말을 볼 수 있다.

데이터베이스 수준의 도움말은 db.help()로 컬렉션 수준의 도움말은 db.foo.help()로 확인한다.

함수의 기능을 알고 싶으면 함수명을 괄호 없이 입력하면 된다.

### 2.7.2 셸에서 스크립트 실행하기

셸을 대화형으로 사용하는 방법 외에 다음과 같이 자바스크립트 파일을 셸로 전달해 실행할 수도 있다.

```jsx
mongo script1.js script2.js script3.js
```

mongo 셸은 각 스크립트를 실행하고 빠져나온다.

### 2.7.3 .mongorc.js 만들기

자주 로드되는 스크립트는 .mongorc.js 파일에 넣을 수 있다. 홈 디렉터리에 .mongorc.js 파일을 만들고 추가한다. dropDatabase나 deleteIndexes 같은 함수가 아무것도 수행하지 않게 재정의하거나 모두 선언 해제할 수 있다.

## 3장 도큐먼트 생성, 갱신, 삭제

### 3.1  도큐먼트 삽입

도큐먼트를 삽입하려면 컬렉션의 insertOne 메소드를 사용한다.

```jsx
> db.movies.insertOne({"title" : "Stand by me"})
```

그러면 도큐먼트에 “_id” 키가 추가되고 도큐먼트가 몽고DB에 저장된다.

**3.1.1 insertMany**

여러 도큐먼트를 컬렉션에 삽입하려면 insertManyfh 도큐먼트 배열을 데이터베이스에 전달한다.

```jsx
	> db.movies.insertMany([{"title" : "Stand by me"}, {"title" : "E.T"}])
```

몽고DB 현재 버전은 48메가바이트보다 큰 메시지를 허용하지 않으므로 48메가바이트보다 큰 삽입을 시도하면 많은 드라이버는 삽입된 데이터를 48메가바이트 크기의 일괄 삽입 여러 개로 분할한다.

insertMany에 대한 두 번째 매개변수로 옵션 도큐먼트를 지정할 수 있다. 도큐먼트가 제공된 순서대로 삽입되도록 옵션 도큐먼트에 “ordered” 키에 true를 지정한다. 순서가 지정되지 않았다면 정렬된 삽입이 기본값이다. 정렬된 삽입의 경우 삽입에 전달된 배열이 삽입 순서를 정의한다. 도큐먼트가 삽입 오류를 생성하면, 배열에서 해당 지점을 벗어난 도큐먼트는 삽입되지 않는다. 정렬되지 않은 삽입의 경우 몽고DB는 일부 삽입이 오류를 발생시키는지 여부에 관계없이 모든 도큐먼트 삽입을 시도한다.

_id가 0, 1, 1, 2로 삽입을 하는 경우 정렬된 삽입에서는 세번째 데이터에서 문제가 발생하기 때문에 앞의 2개의 데이터만 저장이 된다. 반대로 정렬되지 않은 삽입을 지정하면 세번째 데이터를 제외한 0, 1, 2 도큐먼트가 삽입된다.

**3.1.2 삽입 유효성 검사**

몽고DB는 삽입된 데이터에 최소한의 검사를 수행한다. 도큐먼트의 기본 구조를 검사해 “_id” 필드가 존재하지 않으면 새로 추가하고, 모든 도큐먼트는 16메가바이트보다 작아야 하므로 크기 검사를 한다.

**3.1.3 삽입**

몽고DB 3.0 이전 버전에서는 도큐먼트를 몽고DB에 삽입하는 주된 방법이 insert였다. 몽고DB 드라이버는 몽고DB 3.0 서버 릴리스와 동시에 새로운 CRUD API를 선보였다. 몽고DB 3.2의 경우 mongo 셸도 이 API를 지원하는데, insertOne과 insertMany뿐 아니라 다른 여러 방법을 포함한다.

## 3.2 도큐먼트 삭제

CRUD API는 deleteOne과 deleteMany를 제공한다. 두 메서드 모두 필터 도큐먼트를 첫 번째 매개변수로 사용한다.

컬렉션 내 여러 도큐먼트와 일치하는 필터를 지정할 경우 deleteOne은 필터와 일치하는 첫 번째 도큐먼트를 삭제한다. 어떤 도큐먼트가 먼저 발견되는지는 도큐먼트가 삽입된 순서, 도큐먼트에 어떤 갱신이 이뤄졌는지, 어떤 인덱스를 지정하는지 등 몇 가지 요인에 따라 달라진다.

필터와 일치하는 모든 도큐먼트를 삭제하려면 deleteMany를 사용한다.

**3.2.1 drop**

deleteMany를 사용해 컬렉션의 모든 도큐먼트를 제거한다.

전체 컬렉션을 삭제하려면 다음과 같은 drop을 사용하는 편이 더 빠르다.

```jsx
> db.movies.drop()
```

## 3.3 도큐먼트 갱신

updateOne과 updateMany는 필터 도큐먼트를 첫 번째 매개변수로, 변경 사항을 설명하는 수정자 도큐먼트를 두 번째 매개변수로 사용한다.

replcaeOne도 첫 번째 매개변수로 필터를 사용하지만 두 번째 매개변수는 필터와 일치하는 도큐먼트를 교체할 도큐먼트다.

갱신은 원자적으로 이뤄진다. 여러 개의 갱신 요청이 빠르게 발생하더라도 결국 마지막 요청이 최후로 반영된다.

**3.3.1 도큐먼트 치환**

replaceOne은 도큐먼트를 새로운 것으로 완전히 치환한다. 이는 대대적인 스키마 마이그레이션에 유용하다.

흔히 하는 실수로, 조건절로 2개 이상의 도큐먼트가 일치되게 한 후 두 번째 매개변수로 중복된 _id 값을 갖는 도큐먼트를 생성하는 경우가 있다. 이때 데이터 베이스는 오류를 반환하고 아무것도 변경하지 않는다.

**3.3.2 갱신 연산자**

일반적으로 도큐먼트의 특정 부분만 갱신하는 경우가 많다. 부분 갱신에는 원자적 갱신 연산자를 사용한다. 갱신 연산자는 키를 변경, 추가, 제거하고, 심지어 배열과 내장 도큐먼트를 조작하는 복잡한 갱신 연산을 지정하는 특수키다.

컬렉션에 웹사이트 분석 데이터를 저장하고, 누군가가 페이지를 방문할 때마다 카운터를 증가하게 해보자.

```jsx
{
	"_id" : ObjectId("f1f1231d211"),
	"url" : "www.example.com",
	"pageviews" : 52
}
```

pageviews 키의 값을 증가시키려면 $inc 제한자를 사용한다.

```jsx
> db.analytics.updateOne({"url" : "www.example.com"},
...{"$inc" : {"pageviews" : 1}})
```

**“$set” 제한자 사용하기**

$set은 필드 값을 설정한다. 필드가 존재하지 않으면 새 필드가 생성된다. 이 기능은 스키마를 갱신하거나 사용자 정의 키를 추가할 때 편리하다.

```jsx
> db.analytics.updateOne({"url" : "www.example.com"},
...{"$set" : {"pageviews" : 0}})
```

“$set”은 키의 데이터형도 변경할 수 있다.

“$unset”으로 키와 값을 모두 제거할 수 있다.

“$set”은 내장 도큐먼트 내부의 데이터를 변경할 때도 사용한다.

```jsx
> db.blog.posts.updateOne({"author.name" : "joe"},
...{"$set" : {"author.name" : "joe schome"}})
```

키를 추가, 변경, 삭제할 때는 항상 $ 제한자를 사용해야 한다.

**증가와 감소**

**증가와 감소**

“$inc” 연산자는 이미 존재하는 키의 값을 변경하거나 새 키를 생성하는 데 사용한다.

```jsx
> db.games.insertOne({"game" : "pinball", "user" : "joe"})
> db.games.updateOne({"game" : "pinball", "user" : "joe"},
... {"$inc" : {"score" : 50}})
```

score가 없었지만 추가하고 증가한다.

“$Inc”는 int, long, double, decimal 타입 값에만 사용할 수 있다.

**배열 연산자**

배열을 다루는 데 갱신 연산자를 사용할 수 있다. 연산자는 리스트에 대한 인덱스를 지정할 수 있을 뿐 아니라 셋처럼 이중으로 쓸 수 있다.

요소 추가하기

“$push”는 배열이 이미 존재하면 배열 끝에 요소를 추가하고, 존재하지 않으면 새로운 배열을 생성한다.

```jsx
> db.blog.posts.updateOne({"title" : "A blog post"},
... {"$push" : ...})
```

“$push”에 “$each” 제한자를 사용하면 작업 한 번으로 값을 여러개 추가할 수 있다.

```jsx
> db.stock.ticker.updateOne({”_id” : “goog”},
… {”$push” : {”hourly” : {”$each” : [562.776, 562.790]}}})
```

배열을 특정 길이로 늘이려면 “$slice”를 “$push”와 결합해 사용한다. 배열을 특정 크기 이상으로 늘어나지 않게 하고 ‘top N’ 목록을 만들 수 있다.

```jsx
> db.movies.update({"genre" : "horror"},
... {"$push" : {"top10" : {"$each" : ["Nightmare", "saw"],
... {"$slice" : -10}}})
```

트리밍하기 전에 “$sort” 제한자를 “$push” 작업에 적용할 수 있다.

```jsx
> db.movies.updateOne({"genre" : "horror"},
{ "$push" : {"top10" : {"$each" : [{"name" : "Nightmare on Elm Street",
..."rating" : 6.6},
...{"name" : "Saw", "rating" : 4.3}],
..."$slice" : -10,
..."$sort" : {"rating" : -1}}}})
```

배열을 집합으로 사용하기

특정값이 배열에 존재하지 않을때 해당 값을 추가하면서 배열을 집합처럼 처리하려면 쿼리 도큐먼트에 “$ne”를 사용한다.

```jsx
> db.papers.updateOne({"authors cited" : {"$ne" : "Richie"}},
...{$push : {"authors cited" : "Richie"}})

```

“$addToSet”을 사용하면 의미를 좀 더 명확하게 나타낼 수 있다.

고유한 값을 여러개 추가하려면 “$addToSet”과 “$each”를 결합해서 사용하면 된다.

요소 제거하기

배열을 큐나 스택처럼 사용하려면 “$pop”을 사용한다.

{”$pop” : {”key” : 1}} 배열의 마지막 요소부터 제거, {”$pop” : {”key” : -1}} 배열의 처음 요소를 제거

“$pull”은 주어진 조건에 맞는 배열 요소를 제거한다.

```jsx
> db.lists.updateOne({}, {"$pull" : {"todo" : "laundary"}})
```

배열의 위치 기반 변경

배열 내 여러 값을 다루는 방법은 위치를 이용하거나 위치 연산자를 사용한다.

배열 인덱스는 기준이 0이며, 배열 요소는 인덱스 도큐먼트의 키처럼 사용한다.

위치를 이용

```jsx
> db.blog.updateOne({"post" : post_id},
...{"$inc" : {"comments.0.votes" : 1}})
```

아래는 쿼리 도큐먼트와 일치하는 배열 요소 및 요소의 위치를 알아내서 갱신하는 위치 연산자 ”$”를 사용한다.

```jsx
> db.blog.updateOne({"comments.author" : "John"},
...{"$set" : {"comments.$.author" : "Jim"}}) // John인 배열을 찾았기 때문에 $에 John의 index가 들어간다.
```

### 3.3.3 갱신 입력

갱신 입력은 특수한 형태를 갖는 갱신이다. 갱신 조건에 맞는 도큐먼트가 존재하지 않을 때는 쿼리 도큐먼트와 갱신 도큐먼트를 합쳐서 새로운 도큐먼트를 생성한다.

updateOne과 updateMany의 새번째 매개변수는 옵션 도큐먼트로, 갱신 입력을 지정한다.

```jsx
> db.analytics.updateOne({"url" : "/blog"}, {"$inc" : {"pageviews" : 1}},
... {"upsert" : true})
```

저장 셸 보조자

save는 도큐먼트가 존재하지 않으면 도큐먼트를 삽입하고, 존재하면 도큐먼트를 갱신하게하는 셸 함수다.

```jsx
> var x = db.testcol.findOne()
> x.num = 42
42
> db.testcol.save(x)
```

### 3.3.4 다중 도큐먼트 갱신

조건에 맞는 도큐먼트를 모두 수정하려면 updateMany를 사용하자.

### 3.3.5 갱신한 도큐먼트 반환

findOneAndUpdate는 한 번의 연산으로 항목을 반환하고 갱신할 수 있다.

```jsx
> db.processes.findOneAndUpdate({"status" : "READY"},
... {"$set" : {"status" : "RUNNING"}},
... {"sort" : {"priority" : -1}})
```

# 4장 쿼리

## 4.1 find 소개

find 함수는 쿼리에 사용한다. 쿼리는 컬렉션에 도큐먼트의 서브셋을 반환한다.

find의 첫 매개변수에 따라 어떤 도큐먼트를 가져올지 결정하고 빈 쿼리 도큐먼트({})는 컬렉션 내 모든 것과 일치한다. 매개변수에 쿼리 도큐먼트가 없으면 find 함수는 빈 쿼리 도큐먼트로 인식한다.

여러 개의 키/값 쌍을 추가할 수 있다.

```jsx
> db.users.find({"username" : "joe", "age" : 27})
```

### 4.1.1 반환받을 키 지정

반환받은 도큐먼트 내 키/값 정보가 모두 필요하지 않을때는 두 번째 매개변수에 원하는 키를 지정하면 된다.

_id는 지정하지 않아도 항상 반환된다.

```jsx
> db.users.find({}, {"username" : 1, "email" : 1})
```

특정 키값만 가져오지 않으려면 1이 아닌 0을 입력하면 된다. “_id” : 0

### 4.1.2 제약 사항

쿼리 도큐먼트 값은 반드시 상수여야 한다.

```jsx
> db.stock.find({"in_stock" : "this.num_sold"}) // 오류
```

## 4.2 쿼리 조건

### 4.2.1 쿼리 조건절

<, ≤, >, ≥ 에 해당하는 비교 연산자는 각각 “$lt”, “$lte”, “$gt”, “$gte”이다.

```jsx
> db.users.find({"age" : {"gte" : 18, "$lte" : 30"}})
```

“not equal”을 나타내는 “$ne”를 사용할 수 있다.

### 4.2.2 OR 쿼리

“$in”은 하나의 키를 다양한 값과 비교하는 쿼리에 사용한다. “$nin”은 배열 내 조건과 일치하지 않는 도큐먼트를 반환한다.

“$or”은 여러 키를 주어진 값과 비교하는 쿼리에 사용한다.

```jsx
> db.raffle.find({"$or" : [{"tickt_no" : 725}, {"winner" : true}]})
```

### 4.2.4 $not

“$not”은 메타 조건절이며 어떤 조건에도 적용할 수 있다.

“$mod”는 키의 값을 첫번째 값으로 나눈 후 그 나머지 값의 조건을 두번째 값으로 기술하는 연산자다.

```jsx
> db.users.find({"id_num" : {"$mod" : [5, 1]}}) // 1, 6, 11, 16 ...
```

2,3,4,5,7,8의 결과를 얻으려면 “$not”을 사용한다.

```jsx
> db.users.find({"id_num" : {"$not" : {"$mod" : [5, 1]}}})
```

## 4.3 형 특정 쿼리

### 4.3.1 null

null은 스스로와 일치하는 것을 찾는다.

```jsx
> db.c.find({"y" : null}) // y과 null인 것과 해당 키가 없는 도큐먼트를 찾는다.
> db.c.find({"y" : {"$eq" : null, "$exists" : true}})
```

### 4.3.2 정규 표현식

“$regex”는 쿼리에서 패턴 일치 문자열을 위한 정규식 기능을 제공한다.

```jsx
> db.users.find({"name" : {"$regex" : /joe/i}}) // 이름이 Joe, joe인 사용자 찾기
```

몽고DB는 정규 표현식 일치에 펄 호환 정규 표현식(PCRE) 라이브러리를 사용한다.

### 4.3.3 배열에 쿼리하기

배열 요소 쿼리는 스칼라 쿼리와 같은 방식으로 동작하도록 설계됐다.

```jsx
> db.food.insertOne({"fruit" : ["apple", "banana", "peach"]}]
> db.food.find({"fruit" : "banana"})
// 배열을 {"fruit" : "apple", "fruit" : "banana", "fruit" : "peach"}와 동일하게 취급
```

**$all 연산자**

2개 이상의 배열 요소가 일치하는 배열을 찾을 때 “$all”을 사용한다.

```jsx
> db.food.find({"fruit" : {"$all" : ["apple", "banana"]}})
```

정확한 도큐먼트를 찾을 때는 “$all”을 쓰지 않는다.

```jsx
> db.food.find({"fruit" : ["apple", "banana", "peach"]})
```

배열 내 특정 요소를 쿼리하려면 key.index 구문을 이요해 순서를 지정한다.

```jsx
> db.food.find({"fruit.2" : "peach"})
```

**$size 연산자**

“$size”는 특정 크기의 배열을 쿼리하는 유용한 조건절이다.

“$size”는 다른 $ 조건절과 결합해 사용할 수 없지만, 도큐먼트에 “size” 키를 추가하면 이런 쿼리를 처리할 수 있다. 배열에 요소를 추가할 때마다 “size” 값을 증가시킨다.

**$slice 연산자**

find의 두 번째 매개변수는 반환받을 특정 키를 지정한다. “$slice” 연산자를 사용해서 배열 요소의 부분집합을 반환받을 수 있다.

```jsx
> db.blog.posts.findOne(criteria, {"comments" : {"$slice" : 10}})
// 먼저 달린 댓글 10개만 반환
> db.blog.posts.findOne(criteria, {"comments" : {"$slice" : [23, 10]}})
// 처음 23개 건너뛰고, 24번째 요소부터 33번째 요소까지 반환
```

**일치하는 배열 요소의 반환**

특정 기준과 일치하는 배열 요소만 반환

```jsx
> db.blog.posts.find({"comments.name" : "bob"}, {"comments.$" : 1})
// 각 도큐먼트에서 첫 번째로 일치하는 댓글만 반환
```

**배열 및 범위 쿼리의 상호작용**

도큐먼트 내 스칼라(비배열 요소)는 쿼리 기준의 각 절과 일치해야한다.

```jsx
{"x" : 5} {"x" : 15} {"x" : 25} {"x" : [5, 25]}
```

{”x” : {”$gt” : 10, “$lt” : 20}} 으로 쿼리를 하면 4번째 데이터도 조회가 된다.

5가 10보다 작고 25가 10보다 크기 때문이다.

“$elemMatch”를 사용하면 몽고DB는 두 절을 하나의 배열 요소와 비교한다. 하지만 비배열 요소를 일치시키지 않는다.

```jsx
> db.test.find("x" : {"$elemMatch" : {"$gt" : 10, "$lt" : 20}}}) // 결과 없음
```

쿼리하는 필드에 인덱스가 있다면 min 함수와 max함수를 사용해 “$gt”와 “$lt” 값 사이로 인덱스 범위를 제한해 쿼리할 수 있다.

```jsx
> db.test.find("x" : {"$gt" : 10, "$lt" : 20}}).min({"x" : 10}).max({"x" : 20})
```

### 4.3.4 내장 도큐먼트에 쿼리하기

내장 도큐먼트 쿼리는 도큐먼트 전체를 대상으로 하는 방식과 도큐먼트 내 키/값 쌍 각각을 대상으로 하는 방식으로 나뉜다.

```jsx
{
	"name" : {
		"first" : "Joe",
		"last" : "Schmoe"
	},
	"age" : 45
}
```

아래 쿼리로 조회할 수 있다.

```jsx
> db.people.find("name" : {"first" : "Joe", "last" : "Schome"}})
```

그러나 서브도큐먼트 전체에 쿼리하면 서브도큐먼트와 정확히 일치해야한다. 필드가 다르거나 순서가 달라도 조회되지 않는다.

내장 도큐먼트에 쿼리할 때는 가능하다면 특정 키로 쿼리하는 방법이 좋다. 도큐먼트 전체를 대상으로 정확히 일치시키지 않는다.

내장 도큐먼트의 키를 쿼리할 때는 점 표기법을 사용한다.

```jsx
> db.people.fin("name.first" : "Joe", "name.last" : "Schome"})
```

5점 이상을 받은 Joe의 댓글을 찾는다고 가정하자.

```jsx
> db.blog.find()
{
    "content" : "...",
    "comments" : [
        {
            "author" : "joe",
            "score" : 3,
            "comment" : "nice post"
        },
        {
            "author" : "mary",
            "score" : 6,
            "comment" : "terrible post"
        }
    ]
}
```

db.blog.find{(”comments” : {”author” : “joe”, “score” : {”$gt” : 5}}}) 로 쿼리할 수 없다. comment가 없어 정확하게 내장 도큐먼트와 일치하지 않는다.

db.blog.find({”comments.author” : “joe”, “comments.score” : {”$gt” : 5}})도 제대로 동작하지 않는다. 각각의 조건들을 위의 두 도큐먼트가 만족하기 때문이다.

이때 “$elemMatch”를 사용하면 된다.

```jsx
> db.blog.find({"comments" : {"$elemMatch" :
... { "author" : "joe, "score" : {"$gte" : 5}}}})
```