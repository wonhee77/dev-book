# 2장 몽고DB 개발

## 5장 인덱싱

쿼리 플랜 stage 값

- **COLLSCAN** (Collection Scan)
    - 설명: 전체 컬렉션을 스캔합니다. 인덱스를 사용하지 않고 컬렉션의 모든 문서를 순차적으로 검사합니다.
    - 사용 상황: 인덱스가 없거나, 인덱스를 사용할 수 없는 쿼리를 수행할 때.
- **IXSCAN** (Index Scan)
    - 설명: 인덱스를 스캔합니다. 지정된 조건에 따라 인덱스의 항목을 순차적으로 검색합니다.
    - 사용 상황: 쿼리가 인덱스를 사용할 때. 특정 필드에 인덱스가 있는 경우 유리합니다.
- **FETCH**
    - 설명: 인덱스를 통해 문서의 `_id` 값을 찾은 후, 해당 문서를 실제 컬렉션에서 가져옵니다.
    - 사용 상황: IXSCAN 후 실제 문서를 가져와야 할 때.
- **PROJECTION**
    - 설명: 쿼리 결과에서 특정 필드만을 선택합니다.
    - 사용 상황: 쿼리에서 반환할 필드를 지정할 때.
- **SORT**
    - 설명: 쿼리 결과를 정렬합니다. 메모리 내에서 정렬하거나, 메모리가 부족하면 디스크에 임시 파일을 사용하여 정렬합니다.
    - 사용 상황: 쿼리 결과를 특정 순서로 정렬할 때. 인덱스를 사용하지 않고 정렬할 때 성능 저하가 발생할 수 있습니다.
- **LIMIT**
    - 설명: 결과의 수를 제한합니다.
    - 사용 상황: 쿼리 결과에서 반환할 문서의 수를 제한할 때.
- **SKIP**
    - 설명: 결과의 시작 부분을 건너뜁니다.
    - 사용 상황: 쿼리 결과에서 특정 수의 문서를 건너뛸 때.
- **SHARD_MERGE**
    - 설명: 샤딩된 컬렉션에서 각 샤드의 결과를 병합합니다.
    - 사용 상황: 샤딩된 환경에서 쿼리를 실행할 때.
- **SHARDING_FILTER**
    - 설명: 샤드 키를 사용하여 적절한 샤드에서만 데이터를 필터링합니다.
    - 사용 상황: 샤딩된 컬렉션에서 샤드 키를 기반으로 쿼리할 때.
- **COUNT**
    - 설명: 조건에 맞는 문서의 개수를 셉니다.
    - 사용 상황: 쿼리 조건을 만족하는 문서의 개수를 세야 할 때.
- **GROUP**
    - 설명: 그룹화 연산을 수행합니다.
    - 사용 상황: 집계 쿼리에서 그룹화를 사용할 때.
- **AGGREGATE**
    - 설명: 집계 파이프라인을 실행합니다.
    - 사용 상황: 복잡한 집계 연산을 수행할 때.

### 5.1 인덱싱 소개

인덱스를 사용하지 않는 쿼리를 컬렉션 스캔이라하며, 서버가 쿼리 결과를 찾으려면 ‘전체 내용을 살펴봐야 함’을 의미한다.

explain 함수를 이용해 쿼리가 실행될 때 몽고DB가 무얼하는지 확인할 수 있다.

executionStats 모드는 인덱스를 이용한 쿼리의 효과를 이해하는 데 도움이 된다.

```json
> db.users.find({"username" : "user01"}).explain("executionStats")
{
    "queryPlanner": {
        "plannerVersion": 1,
        "namespace": "test.users",
        "indexFilterSet": false,
        "parsedQuery": {
            "username": {
                "$eq": "user101"
            }
        },
        "winningPlan": {
            "stage": "COLLSCAN",
            "filter": {
                "username": {
                    "$eq": "user101"
                }
            },
            "direction": "forward",
            "rejectedPlans": []
        }
    },
    "executionStats": {
        "executionSuccess": true,
        "nReturned": 1,
        "executionTimeMillis": 419,
        "totalKeysExamined": 0,
        "totalDocsExamined": 1000000,
        "executionStages": {
            "stage": "COLLSCAN",
            "filter": {
                "username": {
                    "$eq": "user101"
                }
            },
            "nReturned": 1,
            "executionTimeMillisEstimate": 375,
            "works": 1000002,
            "advanced": 1,
            "needTime": 1000000,
            "needYield": 0,
            "saveState": 7822,
            "restoreState": 7822,
            "isEOF": 1,
            "invalidates": 0,
            "direction": "forward",
            "docsExamined": 1000000
        }
    },
    "serverInfo": {
        "host": "eoinbrazil-laptop-osx",
        "port": 27017,
        "version": "4.0.12",
        "gitVersion": "5776c3cbf9e7afe86e6b29e25220ffb6766e95d4"
    },
    "ok": 1
}
		
```

executionStats.totalDocsExamined는 몽고DB가 쿼리를 실행하면서 살펴본 도큐먼트 개수이며, 인덱스를 설정하지 않았기 때문에 컬렉션에 들어 있는 모든 도큐먼트 개수와 같다.

nReturned 필드는 반환받은 결과의 개수를 보여준다.

### 5.1.1 인덱스 생성

“username” 필드에 인덱스 생성하려면 createIndex 컬렉션 메서드를 사용한다.

```json
> db.users.createIndex({"username" : 1})
{
	"createdCollectionAutomatically" : false,
	"numIndexesBefore" : 1,
	"numIndexesAfter" : 2,
	"ok" : 1
}
```

인덱스를 생성 후 다시 조회를 해보면 totalDocsExamined는 1로 변경되었고, 실행시간도 1로 변경되었다.

인덱스를 생성하면 쓰기 작업은 더 오래 걸리기 때문에 어떤 필드가 인덱싱하기 적합한지 신중히 판단해야 한다.

인덱스를 생성할 대상 필드를 선택하려면, 자주 쓰는 쿼리와 빨리 수행해야 하는 쿼리를 조사해 공통적인 키 셋을 찾아본다.

### 5.1.2 복합 인덱스 소개

상당수의 쿼리 패턴은 두 개 이상의 키를 기반으로 인덱스를 작성해야 한다.

인덱스는 모든 값을 정렬된 순서로 보관하므로 인덱스 키로 도큐먼트를 정렬하는 작업이 훨씬 빨라지게 한다. 하디만 인덱스가 앞 부분에 놓일 때만 정렬에 도움이 된다.

```json
> db.users.find().sort({"age" : 1, "username" : 1})
```

정렬을 최적화 하려면 복합 인덱스를 생성해야 한다.

```json
> db.users.createIndex({"age" : 1, "username" : 1})
```

몽고DB가 실행하는 쿼리의 종류에 따라 인덱스를 사용하는 방법이 다르다. 가장 많이 사용하는 세 가지 방법.

db.users.find({”age” : 21}).sort({”username” : -1})

단일 값을 찾는 동등 쿼리다. 인덱스의 두 번째 필드로 인해 결과는 이미 적절한 순서대로 정렬된다. 즉 몽고DB는 {”age” : 21}과 일치하는 마지막 항목부터 순서대로 인덱스를 탐색한다.

몽고DB는 인덱스를 어느 방향으로도 쉽게 탐색하므로 정렬 방향은 문제가 되지 않는다.

db.users.find({”age” : {”$gte” : 21, “$lte”: 30}})

범위 쿼리이며 여러 값이 일치하는 도큐먼트를 찾아낸다.

몽고DB가 인덱스를 사용해 쿼리하면 일반적으로 인덱스 순서에 따라 도큐먼트 결과를 반환한다.

db.users.find({”age” : {”$gte” : 21, “$lte” : 30}}).sort({”username” : 1})

다중값 쿼리이지만 이번에는 정렬을 포함한다. 사용자명을 정렬된 순서로 반환하지 않기 때문에 결과를 반환하기 전에 메모리에서 정렬해야 함을 의미한다. 따라서 이전 쿼리보다 비효율적이다.

### 5.1.3 몽고DB가 인덱스를 선택하는 방법

5개의 인덱스가 있다고 가정했을때 쿼리가 들어오면 몽고DB는 쿼리 모양을 확인한다. 모양은 검색할 필드와 정렬 여부 등 추가 정보와 관련 있다. 시스템은 이 정보를 기반으로 쿼리를 충족하는 데 사용할 인덱스 후보 집합을 식별한다.

쿼리가 들어고고 인덱스 5개 중 3개 쿼리가 후보로 식별됐다고 가정해보자. 몽고DB는 각 인덱스 후보에 하나씩 총 3개의 쿼리 플랜을 만들고, 각각 다른 인덱스를 사용하는 3개의 병렬 스레드에서 쿼리를 실행한다. 어떤 스레드에서 가장 빨리 결과를 반환하는지 확인하기 위함이다.

가장 먼저 목표 상태에 도달하는 쿼리플랜이 승자가 된다. 또한 앞으로 동일한 모양을 가진 쿼리에 사용할 인덱스로 선택된다는 점이 중요하다. 플랜은 일정 기간 동안 서로 경쟁하며 각 레이스의 결과로 전체 승리 플랜을 산출한다.

쿼리 스레드가 레이스에서 이기려면, 모든 쿼리 결과를 가장 먼저 반환하거나 결과에 대한 시범 횟수를 정렬 순서로 가장 먼저 반환해야 한다.

여러 쿼리 플랜이 서로 경쟁함으로써, 모양이 동일한 후속 쿼리가 있을 때 몽고DB 서버에서 어떤 인덱스를 선택할지 알 수 있다. 서버는 쿼리 플랜의 캐시를 유지하는데, 승리한 플랜은 차후 모양이 같은 쿼리에 사용하기 위해 캐시에 저장된다.

### 5.1.4 복합 인덱스 사용

인덱스의 선택성을 고려한다. 특정 쿼리 패턴에서 스캔할 레코드 개수를 인덱스가 얼마나 최소화 하는지에 관심이 있다.

```json
{
    "_id": ObjectId("585d817db4743f74e2da067c"),
    "student_id": 0,
    "scores": [
        {
            "type": "exam",
            "score": 38.05000060199827
        },
        {
            "type": "quiz",
            "score": 79.45079445008987
        },
        {
            "type": "homework",
            "score": 74.50150548699534
        },
        {
            "type": "homework",
            "score": 74.68381684615845
        }
    ],
    "class_id": 127
}

```

인덱스 두 개로 시작해서 몽고DB가 쿼리를 충족하기 위해 이러한 인덱스를 어떻게 사용하는지 (또는 사용하지 않는지) 살펴본다. 두 인덱스는 다음과 같이 생성한다.

```jsx
> db.students.createIndex({"class_id": 1})
> db.students.createIndex({student_id: 1, class_id: 1})
```

```jsx
> db.students.find({student_id:{"$gt":500000}, class_id:54})
... .sort({student_id:1})
... .explain("executionStats")
```

실행 결과를 살펴보면 “totalKeysExamined”는 몽고DB가 결과 셋을 생성하기 위해 인덱스 내에서 몇 개의 키를 통과했는지 나타낸다. “totalKeysExamined”를 “nReturned”와 비교하면 몽고DB가 일치하는 도큐먼트를 찾으려고 얼마나 많은 인덱스를 통과했는지 나타낸다.

“winningPlan”은 선정된 쿼리 플랜이다.

선정된 플랜은 “student_it”와 “class_id”를 기반으로 복합 인덱스를 사용했다.

```jsx
"winningPlan" : {
"stage" : "FETCH",
"inputStage" : {
	"stage" : "IXSCAN",
	"keyPattern" : {
		"student_id" : 1,
		"class_id" : 1
	},
```

explain 출력은 쿼리 플랜을 단계 트리로 표시한다. 각 단계에는 하위 단계 개수에 따라 하나 이상의 입력 단계가 있을 수 있다. 입력 단계를 도큐먼트나 인덱스 키를 상위 단계에 제공한다.

예제에서는 입력 단계인 인덱스 스캔이 하나 있었고, 해당 스캔은 쿼리와 일치하는 도큐먼트에 대한 레코드 ID를 상위 단계인 “FETCH” 단계에 제공했다. 그러면 “FETCH” 단계는 도큐먼트를 검색하고 클라이언트가 요청하면 일괄적으로 반환한다.

쿼리 플랜에 “SORT”가 표시된다면, 이는 몽고DB가 데이터베이스에서 결과 셋을 정렬할 때 인덱스를 사용할 수 없었으며 대신 인메모리 정렬을 했다는 의미다.

```jsx
"rejectedPlans" : [
	{
		"stage" : "SORT",
		"sortPattern" : {
			"student_id" : 1
		},
```

위의 쿼리에서 student_id : {”$gt” : 500000} 부분은 다중값 부분이고 class_id : 54 부분은 동등 부분이다.

복합 인덱스를 사용할 경우 다중값에서 50만개의 데이터가 선택되지만 class_id 인덱스를 사용할 경우 선택데이터가 500개 정도이다. 따라서 class_id 인덱스를 사용하는게 좋지만 몽고DB가 특정 인덱스를 사용하는것을 강제하는 방법은 좋지 않다.

```jsx
> db.students.createIndex({class_id : 1, student_id : 1})
```

모든 데이터셋에 해당되지는 않지만, 일반적으로 동등 필터를 사용할 필드가 다중값 필터를 사용할 필드보다 앞에 오도록 복합 인덱스를 설계해야 한다.

복합 인덱스를 설계할 때는 인덱스를 사용할 공통 쿼리 패턴의 동등 필터, 다중값 필터, 정렬 구성 요소를 처리하는 방법을 알아야 한다.

복합 인덱스를 설계할 때, 동등 필터 키, 정렬에 사용되는 키 , 다중 필터에 대한 키 순으로 설계하는 것을 가장 우선 순위로 고려해야한다.

**키 방향 선택하기**

지금까지 인덱스는 모두 오름차순으로 정렬됐지만 두 개 이상의 검색 조건으로 정렬할 때는 인덱스 키의 방향이 서로 달라야 한다. 복합 정렬을 서로 다른 방향으로 최적화하려면 방향이 맞는 인덱스를 사용해야 한다.

영방향 인덱스는 서로 동등하다 ({”age” : 1, “username” : -1}, {”age”: -1, “username” : 1})은 같다.

인덱스 방향은 다중 조건에 따라 정렬할 때만 문제가 된다.

**커버드 쿼리 사용하기**

앞 예제에서 인덱스는 항상 적합한 도큐먼트를 찾는데 사용되고, 실제 도큐먼트를 가져오기 위해 곧바로 포인트를 따라간다. 하지만 쿼리가 단지 인덱스에 포함된 필드를 찾는 중이라면 도큐먼트를 가져올 필요는 없다. 인덱스가 쿼리가 요구하는 값을 모두 포함하면, 쿼리가 커버드된다고 한다. 실무에서는 도큐먼트로 되돌아가지 말고 항상 커버드 쿼리를 사용하자. (RDB의 커버링 인덱스 개념)

쿼리가 확실히 인덱스만 사용하게 하려면 “_id” 필드를 반환받지 않도록 반환받을 키를 지정해야 한다.

커버드 쿼리에 explain을 실행하면 결과에 “FETCH” 단계의 하위 단계가 아닌 “IXSCAN” 단계가 있고, “totalDocsExamined” 값이 0이 된다.

**암시적 인덱스**

복합 인덱스는 ‘이중 임무’를 수행할 수 있으며 쿼리마다 다른 인덱스처럼 동작할 수 있다.

a, b, c 키를 복합인덱스로 가진다면 a와 a,b도 복합 인덱스를 가지는 효과를 볼 수 있다.

### 5.1.5 $ 연산자의 인덱스 사용법

**비효율적인 연산자**

“$ne” 쿼리는 인덱스를 사용하긴 하지만 잘 활용하지는 못한다.

```jsx
> db.example.find({"i" : {"$ne" : 3}}).explain()
```

실행 계획을 살펴보면 쿼리는 3보다 작은 인덱스 항목과 3보다 큰 인덱스 항목을 모두 조사한다.

“$not”은 대부분 테이블 스캔을 수행하고, “$nin”은 항상 테이블 스캔을 수행한다.

**범위**

복합 인덱스는 몽고DB가 다중 절 쿼리를 더 효율적으로 실행하도록 돕는다. 다중 필드로 인덱스를 설계할 때는 완전 일치가 사용될 필드를 첫  번째에, 범위가 사용될 필드를 마지막에 놓자.

하나의 쿼리에 두 개의 범위를 사용하면 비효율적인 쿼리 플랜이 된다.

**OR 쿼리**

몽고DB는 쿼리당 하나의 인덱스만 사용할 수 있다. 유일한 예외는 “$or”이다. “$or”은 두 개의 쿼리를 수행하고 결과를 합치므로 “$or”절 마다 하나씩 인덱스를 사용할 수 있다.

일반적으로 두 번 쿼리해서 결과를 병합하면 한 번 쿼리할 때보다 훨씬 비효율적이니 “$in”을 사용하자.

“$in” 쿼리를 실행할 때, 정렬을 제외하면 반환되는 도큐먼트의 순서를 제어하는 방법은 없다.

### 5.1.6 객체 및 배열 인데싱

**내장 도큐먼트 인덱싱하기**

인덱스는 일반적인 키에 생성될 때와 동일한 방식으로 내장 도큐먼트 키에 생성될 수 있다.

```jsx
> db.users.createIndex({"loc.city" : 1})
```

내장 도큐먼트 자체(”loc”)를 인덱싱하면 내장 도큐먼트의 필드(”loc.city”)를 인덱싱 할 때와는 매우 다르게 동작한다. 서브 도큐먼트 전체를 인덱싱하면 서브 도큐먼트 전체에 쿼리할 때만 도움이 된다.

**배열 인덱싱하기**

```jsx
> db.blog.createIndex({"comments.date" : 1})
```

게시글 목록에서 가장 최근에 댓글이 달린 게시물을 찾을 때 이러한 방식을 쓸 수 있다.

“loc”처럼 배열 전체를 단일 개체처럼 인덱싱할 수는 없다. 배열 필드 인덱싱은 배열 자체가 아니라 배열의 각 요소를 인덱싱한다.

복합 인덱스를 구성할 때 하나의 키만 배열로 부터 가져올 수 있다. 여러개를 허용하면 n*m개의 인덱스 항목이 생기기 때문이다.

**다중키 인덱스가 미치는 영향**

도큐먼트가 배열 필드를 인덱스 키로 가지면 인덱스는 즉시 다중키 인덱스로 표시된다. explain()을 출력하면 “isMultiKey”필드가 true다. 인덱스는 한번 다중키로 표시되면 필드 내 배열을 포함하는 도큐먼트가 모두 제거되더라도 비다중키가 될 수 없다.

다중키 인덱스는 하나의 도큐먼트를 여러 개의 인덱스 항목이 가리킬 수 있으므로 결과를 반환하기 전에 몽고DB가 중복을 제거해야한다. 그래서 약간 느릴 수 있다.

### 5.1.7 인덱스 카디널리티

카디널리티는 컬렉션의 한 필드에 대해 고윳값이 얼마나 많은지 나타낸다.

일반적으로 카디널리티가 높을수록 인덱싱에 도움이 된다. 복합 인덱스에서 높은 카디널리티 키를 낮은 카디널리티 키보다 앞에 놓자.

## 5.2 explain 출력

explain은 쿼리에 대한 많은 정보를 제공하며, 느린 쿼리를 위한 중요한 진단 도구이다.

샤딩은 쿼리를 여러 서버에서 수행하므로 explain들의 집합체를 반환한다.

nReturned : 실제로 반환된 도큐먼트 개수

totalKeysExamined : 검색한 인덱스 항목 개수

totlaDocsExamined : 몽고DB가 디스크 내 실제 도큐먼트를 가리키는 인덱스 포인터를 따라간 횟수. 쿼리가 인덱스의 일부가 아닌 검색 조건을 포함하거나, 인덱스에 포함되지 않은 필드를 반환하도록 요청한다면 각 인덱스 항목이 가리키는 도큐먼트를 살펴봐야 한다.

nscannedObjects : 스캔한 도큐먼트 개수

executionTimeMillis : 서버가 요청을 받고 응답을 보낸 시점까지 걸린 시간. 몽고DB가 여러 개의 쿼리 플랜을 시도했다면 “executionTimeMillis”는 최고로 뽑힌 플랜이 아니라 모든 플랜이 실행되기까지 걸린 시간을 반영한다.

istMultiKey : false

stage : 몽고DB가 인덱스를 사용해 쿼리할 수 있었는지 여부. “COLSCAN”은 인덱스로 쿼리할 수 없어 컬렉션 스캔을 수행했음을 뜻한다.

needYields : 쓰기 요청을 처리하도록 쿼리가 양보한 횟수. 대기 중인 쓰시가 있다면 쿼리는 일시적으로 락을 해제하고 쓰기가 처리되게 한다.

indexBounds : 인덱스가 어떻게 사용됐는지 설명하며 탐색한 인덱스의 범위를 제공한다.

## 5.3 인덱스를 생성하지 않는 경우

인덱스는 데이터의 일부를 조회할 때 가장 효율적이며 인덱스가 없는 게 더 빠른 경우도 있다. 인덱스는 컬렉션에서 가져와야 하는 부분이 많을수록 비효율적인데, 인덱스를 하나 사용하려면 두 번의 조회를 해야하기 때문이다.

한 번은 인덱스 항목을 살펴보고, 또 한 번은 도큐먼트를 가리키는 인덱스 포인터를 따라간다.

## 5.4 인덱스 종류

### 5.4.1 고유 인덱스

고유 인덱스는 각 값이 인덱스에 한 번 이하 나타나도록 보장한다.

**복합 고유 인덱스**

개별 키는 같은 값을 가질 수 있지만 인덱스 항목의 키 조합은 인덱스에서 최대 한 번만 나타난다.

### 5.4.2 부분 인덱스

부분 인덱스는 지정된 필터 표현식을 충족하는 컬렉션의 문서만 인덱싱한다.

고유 인덱스는 null을 값으로 취급하므로, 키가 없는 도큐먼트가 여러 개인 고유 인덱스를 만들 수 없다.

하지만 오직 키가 존재할 때만 고유 인덱스가 적용되도록 할 때가 많다. 고유한 필드가 존재하거나 필드가 아예 존재하지 않으면 “unique”와 “partial”을 결합할 수 있다.

부분 인덱스를 만들려면 “partialFilterExpression” 옵션을 포함시킨다.

예를 들어 이메일 주소는 선택 항목이지만 입력할 경우 고유해야 한다.

```jsx
> db.users.ensureIndex({"email" : 1}, {"unique" : true, "partialFilterExpression" : 
... {email : { $exists: true}}})
```

부분 인덱스는 반드시 고유할 필요는 없다. 고유하지 않은 부분 인덱스를 만드려면 “unique” 옵션을 제외 시키기만 하면 된다.

위의 예시에서 email로 조회를 하면 email이 없는 데이터는 조회되지 않는다.

## 5.5 인덱스 관리

데이터베이스의 인덱스 정보는 모두 system.indexes 컬렉션에 저장된다.

특정 컬렉션의 모든 인덱스 정보를 확인하려면 db.컬렉션명.getIndexes()를 실행한다.

### 5.5.1 인덱스 식별

컬렉션 내 각 인덱스는 고유하게 식별하는 이름이 있다. 인덱스명은 서버에서 인덱스를 삭제하거나 조작하는 데 사용된다. 인덱스명은 기본적으로 키이름1-방향1-키이름2-방향2…로 설정된다. createIndex 옵션으로 이름을 지정할 수 있다.

```jsx
> db.soup.createIndex({"a" : 1, "b" : 1, "c" : 1, ...},
... {"name" : "alphabet"})
```

### 5.5.2 인덱스 변경

dropIndex 명령어를 사용해 불필요한 인덱스를 제거할 수 있다.

```jsx
> db.people.dropIndex("x_1_y_1")
```

새로운 인덱스를 생성할 때는 읽기와 쓰기가 모두 멈춘다.

데이터베이스가 읽기와 쓰기에 어느정도 응답하려면 background 옵션을 사용할 수 있지만 foregorund 에서 진행하는 것 보다 훨씬 느리다. 몽고DB 4.2부터는 인덱스 구축 프로세스의 시작과 끝에만 락을 가진다.

## 6장 특수 인덱스와 컬렉션 유형

## 6.1 공간 정보 인덱스

## 6.2 전문 검색을 위한 인덱스

몽고DB의 text 인덱스는 전문 검색의 요구사항을 지원한다.

text 인덱스는 텍스트를 빠르게 검색하는 기능을 제공하며, 언어에 적합한 토큰화, 정지 단어, 형태소 분석 등 일반적인 검색 엔진 요구 사항을 지원한다.

컬렉션에 쓰기 작업을 수행하려면 모든 인덱스를 갱신해야 한다. 텍스트 검색을 사용하면 문자열이 토큰화되고, 형태소화되며, 인덱스는 잠재적으로 여러 위치에서 갱신된다. 따라서 쓰기 비용이 크다.

### 6.2.1 텍스트 인덱스 생성

```jsx
> db.articles.createIndex({"title" : "text", "body" : "text"})
```

가중치를 지정하면 각 필드에 지정하는 상대적 중요도를 제어할 수 있다.

```jsx
> db.articles.createIndex({"title" : "text", "body" : "text"},
{"weights" : {"title" : 3, "body" : 2}})
```

“$**” 키에 인덱스를 만들면 모든 문자열 필드에 전문 인덱스를 생성할 수 있다.

### 6.2.2 텍스트 검색

“$text” 쿼리 연산자를 사용하면 text 인덱스가 있는 컬렉션에 텍스트 검색을 할 수 있다.

```jsx
> db.articles.find({"$text" : {"$search" : "impact crater lunar"}}).limit(10)
```

위의 조회 방식은 두가지 문제가 있다. 각각의 단어를 or 검색하고 검색 결과를 관련성에 따라 정렬하지 않는다.

“\”impact crator\”  lunar” 로 조회를 하면 “impact crator” AND “lunar”로 처리를 한다.

“\”impact crator\”  \”lunar\” \”meteor\” 로 조회하면 “impact crator” AND “ lunar” AND “meteor”로 조회를 한다.

텍스트 쿼리를 사용하면 각 쿼리 결과에 메타데이터가 연결된다. 메타데이터는 $meta연산자를 사용해 명시적으로 투영하지 않으면 쿼리 결과에 표시되지 않는다.

```jsx
> db.articles.find(
  { $text: { $search: "\"impact crater\" lunar" } },
  { title: 1, score: { $meta: "textScore" } }
).sort({score: {"$meta" : "textScore"}}).limit(10)
```

### 6.2.3 전문 검색 최적화

전문 검색을 최적화하는 방법은 두가지다. 다른 기준으로 검색 결과를 좁힐 수 있다면 복합 인덱스를 생성할 때 다른 기준을 앞에 둔다.

또한 다른 기준을 뒤쪽에 두어 사용할 수도 있다.

### 6.2.4 다른 언어로 검색하기

도큐먼트를 입력할 때 “default_language” 로 언어를 지정할수도 있고, 데이터를 삽입할 때 “language 필드에 명시해 도큐먼트별로 형태소 분석 언어를 다르게 지정할 수 있다.

## 6.3 제한 컬렉션

제한 컬렉션은 미리 생성되어 크기가 고정된다.

이미 가득찬 제한 컬렉션에 입력을 시도하면 환형 큐처럼 동작하여 가장 오래된 다큐먼트가 지워지고 새로운 도큐먼트가 그 자리를 차지한다. 도큐먼트는 삭제할 수 없고, 크기가 커지도록 갱신도 허용되지 않는다.

일반적으로 몽고DB TTL 인덱스는 와이어드타이거 스토리지 엔진에서 더 나은 성능을 발휘하므로 제한 컬렉션 보다 권장된다. 제한 컬렉션은 샤딩될 수 없다.

제한 컬렉션은 유연성이 부족하지만 로깅에는 나름 유용하다.

### 6.3.1 제한 컬렉션 생성

일반 컬렉션과 달리 제한 컬렉션은 사용되기 전에 명시적으로 생성돼야 한다.

```jsx
> db.createCollection("my_collection", {"capped" : true, "size" : 100000, 
"max" : 100});
```

10만 바이트 고정 크기와 최대 개수 100을 가진 제한 컬렉션 my_collection을 만든다.

### 6.3.2 꼬리를 무는 커서

꼬리를 무는 커서는 결과를 모두 꺼낸 후에도 종료되지 않는 특수한 형태의 커서로 tail -f 명령어에서 영감을 받아 만들어졌다. 스트림 변경이 꼬리를 무는 커서보다 훨씬 많은 제어와 구성을 제공하여 대부분의 경우에 더 권장된다.

## 6.4 TTL 인덱스

오래된 순 삭제 시스템을 더 유연하게 만들려면 TTL 인덱스를 이용해서 각 도큐먼트에 유효 기간을 설정할 수 있다. 이런 인덱스는 세션 스토리지와 같은 문제를 캐싱하는데 유용하다.

```jsx
> db.sessions.createIndex({"lastUpdated" : 1}, {"expireAfterSeconds" : 60*60*24})
```

“lastUpdated” 필드에 TTL 인덱스를 생성한다. “expiredAfterSeconds”초가 지나면 도큐먼트가 삭제된다.

몽고DB는 인덱스를 매분마다 청소한다.

collMod 명령어를 이용해 “expiredAfterSeconds”를 변경할 수 있다.

하나의 컬렉션에 TTL 인덱스를 여러 개 가질 수 있다.

## 6.5 GridFS로 파일 저장하기

GridFS는 몽고DB에 대용량 이진 파일을 저장하는 매커니즘이다.

## 7장 집계 프레임워크

## 7.1 파이프라인, 단계 및 조정 가능 항목

집계 프레임워크는 몽고DB 내 분석 도구 모음으로, 하나 이상의 컬렉션에 있는 도큐먼트에 대한 분석을 수행하게 해준다.

집계 프레임워크는 파이프라인 개념을 기반으로 한다. 모든 단계의 입력과 출력은 도큐먼트 또는 도큐먼트 스트림이다.

집계 파이프라인의 개별 단계는 데이터 처리 단위다. 입력 도큐먼트 스트림을 한 번에 하나씩 가져와서, 각 도큐먼트를 하나씩 처리하고, 출력 도큐먼트 스트림을 하나씩 생성한다.

각 단계는 knobs 또는 tunalbles 셋을 제공한다. 이 항목들을 조정해 각 단계를 매개변수로 지정함으로써 원하는 작업을 수행할 수 있다.

## 7.2 단계 시작하기: 익숙한 작업들

일치, 선출, 정렬, 건너뛰기, 제한 단계를 살펴보자.

2004년에 설립된 회사를 모두 찾는 간단한 필터를 수행해보자.

```jsx
> db.companies.aggregate([
	{$match : {founded_year: 2004}}}])
```

이는 find를 사용하는 다음 작업과 동일하다.

```jsx
> db.companies.find({founded_year: 2004})
```

```jsx
> db.companies.aggregate([
	{$match : {founded_year: 2004}},
	{$project : {
		_id : 0,
		name: 1,
		founded_year: 1
		}}
	])
```

id는 제거하고 이름과 설립연도만 가져오게 하였다.

```jsx
> db.companies.aggregate([
	{$match : {founded_year: 2004}},
	{$limit : 5},
	{$project : {
		_id : 0,
		name: 1,
		founded_year: 1
		}}
	])
```

limit을 사용하여 제한을 선출 단계 이전에 수행하도록 파이프라인을 구축했다. 선출 이후에 제한을 둘수도 있지만 결과를 제한하기 전에 선출 단계를 통해 수백 개의 도큐먼트를 전달해야한다.

```jsx
> db.companies.aggregate([
	{$match : {founded_year: 2004}},
	{$sort: {name : 1}},
	{$limit : 5},
	{$project : {
		_id : 0,
		name: 1,
		founded_year: 1
		}}
	])
```

제한하기 전에 정렬을 먼저 진행하였다. sort 이전에 skip을 넣어 개수를 건너뛸 수도 있다.

## 7.3 표현식

**불리언 표현식**

AND, OR, NOT 표현식을 쓸 수 있다.

집합 표현식

배열을 집합으로 사용하여 2개 이상의 집합의 교집합이나 합집합을 얻을 수 있다.

비교 표현식

비교 표현식을 통해 다양한 유형의 범위 필터를 표현할 수 있다.

산술 표현식

ceiling, floor, 자연 로그, 로그를 계산할 수 있고 산술 연산을 수행할 수 있다.

문자열 표현식

concatenate, substring 검색, 대소문자 및 텍스트 검색과 관련된 작업을 수행할 수 있다.

배열 표현식

배열 요소를 필터링하거나, 분할, 특정 배열에서 값의 범위를 가져오는 등 조작하는 데 유용하다.

가변적 표현식

리터럴, 날짜 값 구문 분석을 위한식, 조건식을 사용한다.

누산기

합계, 기술 통계 및 기타 여러 유형의 값을 계산하는 기능을 제공한다.

## 7.4 $project

중첩 필드를 승격하는 방법을 살펴보자.

```jsx
 > db.companies.aggregate([
	 {$match : {"funding_rounds.investmensts.financial_org.permalink" : "greylock"}},
	 {$project: {
		 _id: 0,
		 name: 1,
		 ipo: "$ipo.pub_year",
		 valudation : "$ipo.valuation_amount",
		 funders: "$funding_rounds.investments.financial_org.permalink"
		}}
	]).pretty()
```

## 7.5 $unwind

집계 파이프라인에서 배열 필드로 작업할 때는 종종 하나 이상의 unwind 단계를 포함해야 한다. 이를 통해 지정된 배열 필드의 각 요소에 대해 출력 도큐먼트가 하나씩 있는 출력을 생성할 수 있다.

하나의 키에 값이 3개가 있는 경우 unwind를 하면 3개의 도큐먼트가 출력된다.

```jsx
 > db.companies.aggregate([
	 {$match : {"funding_rounds.investmensts.financial_org.permalink" : "greylock"}},
	 {$unwind: "$funding_rounds"},
	 {$project: {
		 _id: 0,
		 name: 1,
		 amount: "$funding_rounds.raised_amount",
		 year: "$funding_rounds.funded_year"
		}}
	]).pretty()
```

unwind 단계는 입력으로 받은 모든 도큐먼트 사본을 생성한다. “funding_rounds” 필드를 제외한 모든 필드는 키와 값이 동일하다. unwind를 하지 않으면 “funding_rounds” 배열의 모든 요소에 대해 “raised_amount”, “funded_year”에 접근한다. 따라서 “amount”와 “year” 둘 다에 대한 배열이 있는 도큐먼트를 생성한다.

project에 “funding_rounds.investments.financial_org.permalink”를 포함한다면 greylock이 포함된 모든 investments를 가져오고 배열로 나타낸다.

```jsx
> db.companies.aggregate([
	 {$match : {"funding_rounds.investmensts.financial_org.permalink" : "greylock"}},
	 {$unwind: "$funding_rounds"},
	 {$match : {"funding_rounds.investmensts.financial_org.permalink" : "greylock"}},
```

위와 같이 unwind와 match의 위치를 바꿔주면 전개를 먼저 하기 때문에 원하는 값을 얻을 수 있지만 풀스캔을 하게되니 match로 greylock이 참여한 투자를 먼저 거르면 된다.

## 7.6 배열 표현식

```jsx
> db.companies.aggregate([
{ $match: {"funding_rounds.investments.financial_org.permalink": "greylock"} },
{ $project: {
	_id: 0,
	name: 1,
	founded_year: 1,
	rounds: { $filter: {
		input: "$funding_rounds",
		as: "round",
		cond: { $gte: ["$$round.raised_amount", 100000000] } } }
},
{ $match: {"rounds.investments.financial_org.permalink": "greylock" } },
	]).pretty()

```

rounds 필드는 필터 표현식을 사용한다. $filter 연산자는 배열 필드와 함께 작동하도록 설계됐다.

$filter의 첫 번째 옵션은 input이며 단순히 배열을 지정한다. 다음으로 나머지 필터 표현식 전체에서 “funding_rounds” 배열에 사용할 이름을 지정한다. 세 번째 옵션으로는 조건을 지정한다.

조건은 입력으로 지정한 배열을 필터링하는 기준으로 제공해 서브셋을 선택하도록 한다. $$는 작업 중인 표현식 내에서 정의된 변수를 참조하는 데 사용한다.

$arrayElemAt 연산자를 사용하면 배열 내 특정 슬록에서 요소를 선택할 수 있다.

$slice 표현식은 $arrayElemAt와 관련 있다. 표현식을 사용하면 배열의 특정 인덱스에서 시작해 하나뿐 아니라 여러 항목을 순서대로 반환할 수 있다.

배열의 크기는 $size 연산자로 수행할 수 있다.

## 7.7 누산기

집계 프레임워크가 제공하는 누산기를 사용하면 특정 필드의 모든 값 합산($sum), 평균 계산($avg) 등의 작업을 할 수 있다. $first와 $last도 누산기로 간주하는데 표현식이 사용된 단계를 통과하는 모든 도큐먼트 내 값을 고려하기 때문이다. $max와 $min은 도큐먼트 스트림을 고려해 표시되는 값 중 하나만 저장하는 누산기다. $mergeObjects를 사용하면 여러 도큐먼트를 하나의 도큐먼트로 결합할 수 있다.

배열용 누산기로 도큐먼트가 파이프라인 단계를 통과할 때 배열에 값을 $push할 수 있다.

$addToSet은 $push와 유사하지만 결과 배열에 중복 값이 포함되지 않게 한다는 차이가 있다.

### 7.7.1 선출 단계에서 누산기 사용

```jsx
> db.companies.aggregate([
	{$match : {"funding_rounds" : {$exists : true, $ne : []}}},
	{$project : {
		_id : 0,
		name : 1,
		largest_round : {$max : "$funding_rounds.raised_amount"}
		}}
	])
```

선출 단계에서 누산기는 배열값 필드에서 작동해야한다.

## 7.8 그룹화 소개

그룹 단계는 SQL GROUP BY 명령과 유사한 기능을 수행한다.

```jsx
> db.companies.aggregate([
	{$group : {
		_id : {founded_year : "$founded_year"},
		average_number_of_employees : {$avg : "$number_of_employees"}
	}},
	{$sort : {average_number_of_employees: -1}}
	])
```

설립 연도를 기준으로 회사를 합친 다음 연도마다 평균 직원수를 계산한다.

그룹 단계의 기본은 도큐먼트의 일부로 지정하는 “_id” 필드다.

### 7.8.1 그룹 단계의 _id 필드

```jsx
> db.companies.aggregate([
{$match : {founded_year : {$age: 2013}}},
{$group : {
	_id : {founded_year : "$founded_year"},
	companies : {$push : "$name"}
}},
{$sort : {"_id.founded_year" : 1}}
]).pretty()
```

의미를 명확하게 하기 위해 _id 필드안에 founded_year이라는 레이블을 넣었다.

경우에 따라 여러 필드로 구성된 도큐먼트 _id 값인 방식을 사용해야 할 수도 있다.

### 7.8.2 그룹 vs. 선출

```jsx
> db.companies.aggregate([
  { $match: { funding_rounds: { $ne: [ ] } } },
  { $unwind: "$funding_rounds" },
  { $sort: { "funding_rounds.funded_year": 1,
             "funding_rounds.funded_month": 1,
             "funding_rounds.funded_day": 1 } },
  { $group: {
      _id: { company: "$name" },
      funding: {
        $push: {
          amount: "$funding_rounds.raised_amount",
          year: "$funding_rounds.funded_year"
        }
      }
    }
  },
]).pretty()
```

$push 표현식은 그룹 단계에서만 작동한다. 그룹 단계가 도큐먼트의 입력 스트림을 가져와 각 도큐먼트를 차례로 처리해 값을 축적하도록 설계됐기 때문이다. 반면에 선출 단계는 입력 스트림의 각 도큐먼트에 대해 개별적으로 작동한다.

$push와 마찬가지로 선출 단계에서는 $first와 $last를 사용할 수 없다. 선출 단계는 해당 단계를 통해 스트리밍되는 여러 도큐먼트를 기반으로 값을 누적하도록 설계되지 않았기 때문이다.

## 7.9 집계 파이프라인 결과를 컬렉션에 쓰기

집계 파이프라인에서 생성된 도큐먼트를 컬렉션에 쓸 수 있는 두 가지 단계로 $out과 $merger가 있다.

## 8장 트랜잭션

## 8.1 트랜잭션 소개

트랜잭션은 읽기나 쓰기 작업이 가능한 데이터베이스 작업을 하나 이상 포함하는 데이터베이스의 논리적 처리 단위다.

### 8.1.1 ACID의 정의

ACID는 원자성 Atomicity, 일관성 consistency, 고립성 isolation, 영속성 duration의 약어이다.

원자성은 트랜잭션 내 모든 작업이 적용되거나 아무 작업도 적용되지 않도록 한다.

일관성은 트랜잭션이 성공하면 데이터베이스가 하나의 일관성 있는 상태에서 다음 일관성 있는 상태로 이동하도록 한다.

고립성은 여러 트랜잭션이 데이터베이스에서 동시에 실행되도록 허용하는 속성이다. 트랜잭션이 다른 트랜잭션의 부분 결과를 보지 않도록 보장한다.

영속성은 트랜잭션이 커밋될 때 시스템 오류가 발생하더라도 모든 데이터가 유지되도록 한다.

## 8.2 트랜잭션 사용법

몽고DB는 트랜잭션을 사용하기 위한 두 가지 API를 제공한다. 첫 번째는 코어 API라는 관계형 데이터베이스와 유사한 구문이고, 두 번째는 트랜잭션 사용에 권장되는 접근 방식인 콜백 API다.

코어API는 대부분의 오류에 재시도 로직을 제공하지 않고 개발자가 작업에 대한 로직, 트랜잭션 커밋 함수, 필요한 재시도 및 오류 로직을 모두 작성해야 한다.

콜백 API는 지정된 논리 세션과 관련된 트랜잭션 시작, 콜백 함수로 제공된 함수 실행, 트랜잭션 커밋을 포함해 코어 API에 비해 많은 기능을 래핑하는 단일 함수를 제공한다.

## 8.3 애플리케이션을 위한 트랜잭션 제한 조정

### 8.3.1 타이밍과 Oplog 크기 제한

**시간 제한**

트랜잭션 최대 실행 시간은 기본적으로 1분 이하다. mongod 인스턴스 레벨에서 transactionLifetimeLimitSeconds에 의해 제어되는 제한을 수정해 증가시킬 수 있다.

시간이 경과하면 트랜잭션이 만료됐다고 간주하여 주기적으로 실행되는 정리 프로세스에 의해 중단된다.

트랜잭션의 작업에 필요한 락을 획득하기 위해 트랜잭션이 대기하는 최대 시간은 기본적으로 5millis다. 이 값은 maxTransactionLockRequestTimeoutMillis에 의해 제어되는 제한을 수정해 늘릴 수 있다.

**Oplog 크기 제한**

몽고DB는 트랜잭션의 쓰기 작업에 필요한 만큼 oplog 항목을 생성한다. 그러나 각 oplog 항목은 BSON 도큐먼트 크기 제한인 16메가바이트 이하여야 한다.

## 9장 애플리케이션 설계

## 9.1 스키마 설계 고려 사항

스키마를 모델링하기 전에 먼저 쿼리 및 데이터 접근 패턴을 이해해야 한다.

**제약 사항**

도큐먼트의 최대 크기는 16메가바이트이며, 디스크에서 전체 도큐먼트를 읽고 쓴다. 갱신은 전체 도큐먼트를 다시 쓰며, 원자성 갱신은 도큐먼트 단위로 실행된다.

**쿼리 및 쓰기의 접근 패턴**

애플리케이션의 읽기와 쓰기를 포함한 워크로드를 분석하여 일반적인 쿼리를 식별하고, 스키마를 설계할 때 필요한 쿼리를 최소화하며 관련 데이터를 동일한 도큐먼트에 저장하도록 설계해야 한다.

자주 사용되지 않는 데이터는 다른 컬렉션으로 이동하고, 동적 데이터(읽기/쓰기)와 정적 데이터(대부분 읽기)를 분리하는 것을 고려해야 한다.

스키마 설계의 우선 순위를 일반적인 쿼리에 맞추어 최상의 성능을 얻도록 한다.

**관계 유형**

애플리케이션 요구 사항 측명과 도큐먼트 간 관계 측면에서 어떤 데이터가 관련돼 있는지 고려해야 한다.

**카디널리티**

도큐먼트와 데이터가 어떻게 관련돼 있는지 확인한 후에는 관계의 카디널리티를 고려해야 한다.

### 9.1.1 스키마 설계 패턴

**다형성 패턴**

다형성 패턴은 컬렉션 내 모든 도큐먼트가 유사하지만 동일하지 않은 구조를 가질 때 적합하다. 동일하지 않은 도큐먼트로 구성된 단일 컬렉션에서 간단한 쿼리를 사용해 쿼리 성능을 향상시킬 수 있다.

**속성 패턴**

속성 패턴은 정렬하거나 쿼리하려는 도큐먼트에 필드의 서브셋이 있는 경우, 정렬하려는 필드가 도큐먼트의 서브셋에만 존재하는 경우 또는 두 조건이 모두 해당되는 경우에 적합하다.

**버킷 패턴**

버킷 패턴은 데이터가 일정 기간 동안 스트림으로 유입되는 시계열 데이터에 적합하다.

**이상치 패턴**

드물게 도큐먼트의 쿼리가 애플리케이션의 정상적인 패턴을 벗어날 때 사용한다.

**계산된 패턴**

데이터를 자주 계산해야 할 때나 데이터 접근 패턴이 읽기 집약적일 때 사용한다.

**서브셋 패턴**

장비의 램 용량을 초과하는 작업 셋이 있을 때 사용한다. 자주 사용하는 데이터와 자주 사용하지 않는 데이터를 두 개의 개별 컬렉션으로 분할 한다.

**확장된 참조 패턴**

각각 고유한 컬렉션이 있는 여러 논리 엔티티가 있고 특정 기능을 위해 엔티티들을 모을 때 사용한다.

**근사 패턴**

리소스가 많이 드는 계산이 필요하지만 정확도가 반드시 필요하지 않은 상황에 유용하다.

**트리 패턴**

쿼리가 많고 구조적으로 주로 계층적인 데이터가 있을 때 적용한다.

전체 계층구조 필드는 배열에 보관돼 해당 값에 다중키 인덱스를 사용하는 기능을 제공한다. 따라서 계층구조의 범주와 관련된 모든 항목을 쉽게 찾을 수 있다. 즉각적인 범주 필드를 사용하면 해당 범주와 직접 관련된 모든 항목을 찾을 수 있다.

**사전 할당 패턴**

**도큐먼트 버전 관리 패턴**

## 9.2 정규화 vs. 비정규화

정규화는 컬렉션 간의 참조를 이용해 데이터를 여러 컬렉션으로 나누는 작업이다. 각 데이터 조각은 여러 도큐먼트가 참조할 수 있지만 하나의 컬렉션에 들어 있다.

몽고DB 집계 프레임워크는 소스 컬렉션에 일치하는 도큐먼트가 있는 결합된 컬렉션에 도큐먼트를 추가해 left outer join을 수행하는 $lookup 단계와 조인을 제공한다.

비정규화는 모든 데이터를 하나의 도큐먼트에 내장하는 것으로 정규화의 반대다.

일반적으로 정규화는 쓰기를 빠르게 만들고 비정규화는 읽기를 빠르게 만든다.

### 9.2.1 데이터 표현 예제

혼합된 확장 참조는 자주 사용하는 정보로 서브도큐먼트의 배열을 생성하고, 추가적인 정보는 실제 도큐먼트를 참조하는 방식이다.

내장 도큐먼트를 사용하기로 결정하고 도큐먼트를 갱신해야 한다면, 모든 도큐먼트가 성공적으로 갱신되도록 보장하기 위해 cron 작업을 설정해야 한다.

갱신 연산자 측면에서 “$set”은 멱등이지만 “$inc”는 그렇지 않다. 멱등 연산은 한 번 시도하든 여러 번 시도하든 동일한 결과를 나타낸다. 멱등이 아닌 연산자의 경우 작업을 두 개로, 즉 개별로적으로 멱등이며 재시도해도 안전한 작업으로 분리해야 한다. 첫 번째 작업에 고유한 보류 토큰을 포함하고, 두 번째 작업에서 고유한 키와 고유한 보류 토큰을 모두 사용하게 하면 된다.

### 9.2.2 카디널리티

카디널리티는 컬렉션이 다른 컬렉션을 얼마나 참조하는지 나타내는 개념이다.

일반적으로 ‘적음’ 관계는 내장이 더 적합하고 ‘많음’ 관계는 참조가 더 적합하다.

### 9.2.3 친구, 팔로워 그리고 불편한 관계

구독을 구현하는 전형적인 방법은 세 가지가 있다.

첫 번째 방법은 게시자를 구독자의 도큐먼트에 넣는 방법이다. 두 번째 방법은 구독자를 게시자의 도큐먼트에 넣는 방법이다. 마지막 옵션은 좀 더 정규화하고 구독을 다른

컬렉션에 저장함으로써 이러한 단점을 완화한다.

**유명인 사용자로 인한 영향 대처하기**

유명인 사용자의 팔로워를 저장하는 도큐먼트는 넘칠 수 있다. 이상치 패턴을 사용하고 필요하다면 ‘연속’ 도큐먼트를 사용해 해결할 수 있다.

‘to be continued’(”tbc”) 배열에 애플리케이션 로직을 추가하면 다음 id를 불러와 다음 목록을 확인할 수 있다.