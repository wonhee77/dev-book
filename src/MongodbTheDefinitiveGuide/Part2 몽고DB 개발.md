# 2장 몽고DB 개발

## 5장 인덱싱

쿼리 플랜 stage 값

- **COLLSCAN** (Collection Scan)
    - 설명: 전체 컬렉션을 스캔합니다. 인덱스를 사용하지 않고 컬렉션의 모든 문서를 순차적으로 검사합니다.
    - 사용 상황: 인덱스가 없거나, 인덱스를 사용할 수 없는 쿼리를 수행할 때.
- **IXSCAN** (Index Scan)
    - 설명: 인덱스를 스캔합니다. 지정된 조건에 따라 인덱스의 항목을 순차적으로 검색합니다.
    - 사용 상황: 쿼리가 인덱스를 사용할 때. 특정 필드에 인덱스가 있는 경우 유리합니다.
- **FETCH**
    - 설명: 인덱스를 통해 문서의 `_id` 값을 찾은 후, 해당 문서를 실제 컬렉션에서 가져옵니다.
    - 사용 상황: IXSCAN 후 실제 문서를 가져와야 할 때.
- **PROJECTION**
    - 설명: 쿼리 결과에서 특정 필드만을 선택합니다.
    - 사용 상황: 쿼리에서 반환할 필드를 지정할 때.
- **SORT**
    - 설명: 쿼리 결과를 정렬합니다. 메모리 내에서 정렬하거나, 메모리가 부족하면 디스크에 임시 파일을 사용하여 정렬합니다.
    - 사용 상황: 쿼리 결과를 특정 순서로 정렬할 때. 인덱스를 사용하지 않고 정렬할 때 성능 저하가 발생할 수 있습니다.
- **LIMIT**
    - 설명: 결과의 수를 제한합니다.
    - 사용 상황: 쿼리 결과에서 반환할 문서의 수를 제한할 때.
- **SKIP**
    - 설명: 결과의 시작 부분을 건너뜁니다.
    - 사용 상황: 쿼리 결과에서 특정 수의 문서를 건너뛸 때.
- **SHARD_MERGE**
    - 설명: 샤딩된 컬렉션에서 각 샤드의 결과를 병합합니다.
    - 사용 상황: 샤딩된 환경에서 쿼리를 실행할 때.
- **SHARDING_FILTER**
    - 설명: 샤드 키를 사용하여 적절한 샤드에서만 데이터를 필터링합니다.
    - 사용 상황: 샤딩된 컬렉션에서 샤드 키를 기반으로 쿼리할 때.
- **COUNT**
    - 설명: 조건에 맞는 문서의 개수를 셉니다.
    - 사용 상황: 쿼리 조건을 만족하는 문서의 개수를 세야 할 때.
- **GROUP**
    - 설명: 그룹화 연산을 수행합니다.
    - 사용 상황: 집계 쿼리에서 그룹화를 사용할 때.
- **AGGREGATE**
    - 설명: 집계 파이프라인을 실행합니다.
    - 사용 상황: 복잡한 집계 연산을 수행할 때.

### 5.1 인덱싱 소개

인덱스를 사용하지 않는 쿼리를 컬렉션 스캔이라하며, 서버가 쿼리 결과를 찾으려면 ‘전체 내용을 살펴봐야 함’을 의미한다.

explain 함수를 이용해 쿼리가 실행될 때 몽고DB가 무얼하는지 확인할 수 있다.

executionStats 모드는 인덱스를 이용한 쿼리의 효과를 이해하는 데 도움이 된다.

```json
> db.users.find({"username" : "user01"}).explain("executionStats")
{
    "queryPlanner": {
        "plannerVersion": 1,
        "namespace": "test.users",
        "indexFilterSet": false,
        "parsedQuery": {
            "username": {
                "$eq": "user101"
            }
        },
        "winningPlan": {
            "stage": "COLLSCAN",
            "filter": {
                "username": {
                    "$eq": "user101"
                }
            },
            "direction": "forward",
            "rejectedPlans": []
        }
    },
    "executionStats": {
        "executionSuccess": true,
        "nReturned": 1,
        "executionTimeMillis": 419,
        "totalKeysExamined": 0,
        "totalDocsExamined": 1000000,
        "executionStages": {
            "stage": "COLLSCAN",
            "filter": {
                "username": {
                    "$eq": "user101"
                }
            },
            "nReturned": 1,
            "executionTimeMillisEstimate": 375,
            "works": 1000002,
            "advanced": 1,
            "needTime": 1000000,
            "needYield": 0,
            "saveState": 7822,
            "restoreState": 7822,
            "isEOF": 1,
            "invalidates": 0,
            "direction": "forward",
            "docsExamined": 1000000
        }
    },
    "serverInfo": {
        "host": "eoinbrazil-laptop-osx",
        "port": 27017,
        "version": "4.0.12",
        "gitVersion": "5776c3cbf9e7afe86e6b29e25220ffb6766e95d4"
    },
    "ok": 1
}
		
```

executionStats.totalDocsExamined는 몽고DB가 쿼리를 실행하면서 살펴본 도큐먼트 개수이며, 인덱스를 설정하지 않았기 때문에 컬렉션에 들어 있는 모든 도큐먼트 개수와 같다.

nReturned 필드는 반환받은 결과의 개수를 보여준다.

### 5.1.1 인덱스 생성

“username” 필드에 인덱스 생성하려면 createIndex 컬렉션 메서드를 사용한다.

```json
> db.users.createIndex({"username" : 1})
{
	"createdCollectionAutomatically" : false,
	"numIndexesBefore" : 1,
	"numIndexesAfter" : 2,
	"ok" : 1
}
```

인덱스를 생성 후 다시 조회를 해보면 totalDocsExamined는 1로 변경되었고, 실행시간도 1로 변경되었다.

인덱스를 생성하면 쓰기 작업은 더 오래 걸리기 때문에 어떤 필드가 인덱싱하기 적합한지 신중히 판단해야 한다.

인덱스를 생성할 대상 필드를 선택하려면, 자주 쓰는 쿼리와 빨리 수행해야 하는 쿼리를 조사해 공통적인 키 셋을 찾아본다.

### 5.1.2 복합 인덱스 소개

상당수의 쿼리 패턴은 두 개 이상의 키를 기반으로 인덱스를 작성해야 한다.

인덱스는 모든 값을 정렬된 순서로 보관하므로 인덱스 키로 도큐먼트를 정렬하는 작업이 훨씬 빨라지게 한다. 하디만 인덱스가 앞 부분에 놓일 때만 정렬에 도움이 된다.

```json
> db.users.find().sort({"age" : 1, "username" : 1})
```

정렬을 최적화 하려면 복합 인덱스를 생성해야 한다.

```json
> db.users.createIndex({"age" : 1, "username" : 1})
```

몽고DB가 실행하는 쿼리의 종류에 따라 인덱스를 사용하는 방법이 다르다. 가장 많이 사용하는 세 가지 방법.

db.users.find({”age” : 21}).sort({”username” : -1})

단일 값을 찾는 동등 쿼리다. 인덱스의 두 번째 필드로 인해 결과는 이미 적절한 순서대로 정렬된다. 즉 몽고DB는 {”age” : 21}과 일치하는 마지막 항목부터 순서대로 인덱스를 탐색한다.

몽고DB는 인덱스를 어느 방향으로도 쉽게 탐색하므로 정렬 방향은 문제가 되지 않는다.

db.users.find({”age” : {”$gte” : 21, “$lte”: 30}})

범위 쿼리이며 여러 값이 일치하는 도큐먼트를 찾아낸다.

몽고DB가 인덱스를 사용해 쿼리하면 일반적으로 인덱스 순서에 따라 도큐먼트 결과를 반환한다.

db.users.find({”age” : {”$gte” : 21, “$lte” : 30}}).sort({”username” : 1})

다중값 쿼리이지만 이번에는 정렬을 포함한다. 사용자명을 정렬된 순서로 반환하지 않기 때문에 결과를 반환하기 전에 메모리에서 정렬해야 함을 의미한다. 따라서 이전 쿼리보다 비효율적이다.

### 5.1.3 몽고DB가 인덱스를 선택하는 방법

5개의 인덱스가 있다고 가정했을때 쿼리가 들어오면 몽고DB는 쿼리 모양을 확인한다. 모양은 검색할 필드와 정렬 여부 등 추가 정보와 관련 있다. 시스템은 이 정보를 기반으로 쿼리를 충족하는 데 사용할 인덱스 후보 집합을 식별한다.

쿼리가 들어고고 인덱스 5개 중 3개 쿼리가 후보로 식별됐다고 가정해보자. 몽고DB는 각 인덱스 후보에 하나씩 총 3개의 쿼리 플랜을 만들고, 각각 다른 인덱스를 사용하는 3개의 병렬 스레드에서 쿼리를 실행한다. 어떤 스레드에서 가장 빨리 결과를 반환하는지 확인하기 위함이다.

가장 먼저 목표 상태에 도달하는 쿼리플랜이 승자가 된다. 또한 앞으로 동일한 모양을 가진 쿼리에 사용할 인덱스로 선택된다는 점이 중요하다. 플랜은 일정 기간 동안 서로 경쟁하며 각 레이스의 결과로 전체 승리 플랜을 산출한다.

쿼리 스레드가 레이스에서 이기려면, 모든 쿼리 결과를 가장 먼저 반환하거나 결과에 대한 시범 횟수를 정렬 순서로 가장 먼저 반환해야 한다.

여러 쿼리 플랜이 서로 경쟁함으로써, 모양이 동일한 후속 쿼리가 있을 때 몽고DB 서버에서 어떤 인덱스를 선택할지 알 수 있다. 서버는 쿼리 플랜의 캐시를 유지하는데, 승리한 플랜은 차후 모양이 같은 쿼리에 사용하기 위해 캐시에 저장된다.

### 5.1.4 복합 인덱스 사용

인덱스의 선택성을 고려한다. 특정 쿼리 패턴에서 스캔할 레코드 개수를 인덱스가 얼마나 최소화 하는지에 관심이 있다.

```json
{
    "_id": ObjectId("585d817db4743f74e2da067c"),
    "student_id": 0,
    "scores": [
        {
            "type": "exam",
            "score": 38.05000060199827
        },
        {
            "type": "quiz",
            "score": 79.45079445008987
        },
        {
            "type": "homework",
            "score": 74.50150548699534
        },
        {
            "type": "homework",
            "score": 74.68381684615845
        }
    ],
    "class_id": 127
}

```

인덱스 두 개로 시작해서 몽고DB가 쿼리를 충족하기 위해 이러한 인덱스를 어떻게 사용하는지 (또는 사용하지 않는지) 살펴본다. 두 인덱스는 다음과 같이 생성한다.

```jsx
> db.students.createIndex({"class_id": 1})
> db.students.createIndex({student_id: 1, class_id: 1})
```

```jsx
> db.students.find({student_id:{"$gt":500000}, class_id:54})
... .sort({student_id:1})
... .explain("executionStats")
```

실행 결과를 살펴보면 “totalKeysExamined”는 몽고DB가 결과 셋을 생성하기 위해 인덱스 내에서 몇 개의 키를 통과했는지 나타낸다. “totalKeysExamined”를 “nReturned”와 비교하면 몽고DB가 일치하는 도큐먼트를 찾으려고 얼마나 많은 인덱스를 통과했는지 나타낸다.

“winningPlan”은 선정된 쿼리 플랜이다.

선정된 플랜은 “student_it”와 “class_id”를 기반으로 복합 인덱스를 사용했다.

```jsx
"winningPlan" : {
"stage" : "FETCH",
"inputStage" : {
	"stage" : "IXSCAN",
	"keyPattern" : {
		"student_id" : 1,
		"class_id" : 1
	},
```

explain 출력은 쿼리 플랜을 단계 트리로 표시한다. 각 단계에는 하위 단계 개수에 따라 하나 이상의 입력 단계가 있을 수 있다. 입력 단계를 도큐먼트나 인덱스 키를 상위 단계에 제공한다.

예제에서는 입력 단계인 인덱스 스캔이 하나 있었고, 해당 스캔은 쿼리와 일치하는 도큐먼트에 대한 레코드 ID를 상위 단계인 “FETCH” 단계에 제공했다. 그러면 “FETCH” 단계는 도큐먼트를 검색하고 클라이언트가 요청하면 일괄적으로 반환한다.

쿼리 플랜에 “SORT”가 표시된다면, 이는 몽고DB가 데이터베이스에서 결과 셋을 정렬할 때 인덱스를 사용할 수 없었으며 대신 인메모리 정렬을 했다는 의미다.

```jsx
"rejectedPlans" : [
	{
		"stage" : "SORT",
		"sortPattern" : {
			"student_id" : 1
		},
```

위의 쿼리에서 student_id : {”$gt” : 500000} 부분은 다중값 부분이고 class_id : 54 부분은 동등 부분이다.

복합 인덱스를 사용할 경우 다중값에서 50만개의 데이터가 선택되지만 class_id 인덱스를 사용할 경우 선택데이터가 500개 정도이다. 따라서 class_id 인덱스를 사용하는게 좋지만 몽고DB가 특정 인덱스를 사용하는것을 강제하는 방법은 좋지 않다.

```jsx
> db.students.createIndex({class_id : 1, student_id : 1})
```

모든 데이터셋에 해당되지는 않지만, 일반적으로 동등 필터를 사용할 필드가 다중값 필터를 사용할 필드보다 앞에 오도록 복합 인덱스를 설계해야 한다.

복합 인덱스를 설계할 때는 인덱스를 사용할 공통 쿼리 패턴의 동등 필터, 다중값 필터, 정렬 구성 요소를 처리하는 방법을 알아야 한다.

복합 인덱스를 설계할 때, 동등 필터 키, 정렬에 사용되는 키 , 다중 필터에 대한 키 순으로 설계하는 것을 가장 우선 순위로 고려해야한다.

**키 방향 선택하기**

지금까지 인덱스는 모두 오름차순으로 정렬됐지만 두 개 이상의 검색 조건으로 정렬할 때는 인덱스 키의 방향이 서로 달라야 한다. 복합 정렬을 서로 다른 방향으로 최적화하려면 방향이 맞는 인덱스를 사용해야 한다.

영방향 인덱스는 서로 동등하다 ({”age” : 1, “username” : -1}, {”age”: -1, “username” : 1})은 같다.

인덱스 방향은 다중 조건에 따라 정렬할 때만 문제가 된다.

**커버드 쿼리 사용하기**

앞 예제에서 인덱스는 항상 적합한 도큐먼트를 찾는데 사용되고, 실제 도큐먼트를 가져오기 위해 곧바로 포인트를 따라간다. 하지만 쿼리가 단지 인덱스에 포함된 필드를 찾는 중이라면 도큐먼트를 가져올 필요는 없다. 인덱스가 쿼리가 요구하는 값을 모두 포함하면, 쿼리가 커버드된다고 한다. 실무에서는 도큐먼트로 되돌아가지 말고 항상 커버드 쿼리를 사용하자. (RDB의 커버링 인덱스 개념)

쿼리가 확실히 인덱스만 사용하게 하려면 “_id” 필드를 반환받지 않도록 반환받을 키를 지정해야 한다.

커버드 쿼리에 explain을 실행하면 결과에 “FETCH” 단계의 하위 단계가 아닌 “IXSCAN” 단계가 있고, “totalDocsExamined” 값이 0이 된다.

**암시적 인덱스**

복합 인덱스는 ‘이중 임무’를 수행할 수 있으며 쿼리마다 다른 인덱스처럼 동작할 수 있다.

a, b, c 키를 복합인덱스로 가진다면 a와 a,b도 복합 인덱스를 가지는 효과를 볼 수 있다.

### 5.1.5 $ 연산자의 인덱스 사용법

**비효율적인 연산자**

“$ne” 쿼리는 인덱스를 사용하긴 하지만 잘 활용하지는 못한다.

```jsx
> db.example.find({"i" : {"$ne" : 3}}).explain()
```

실행 계획을 살펴보면 쿼리는 3보다 작은 인덱스 항목과 3보다 큰 인덱스 항목을 모두 조사한다.

“$not”은 대부분 테이블 스캔을 수행하고, “$nin”은 항상 테이블 스캔을 수행한다.

**범위**

복합 인덱스는 몽고DB가 다중 절 쿼리를 더 효율적으로 실행하도록 돕는다. 다중 필드로 인덱스를 설계할 때는 완전 일치가 사용될 필드를 첫  번째에, 범위가 사용될 필드를 마지막에 놓자.

하나의 쿼리에 두 개의 범위를 사용하면 비효율적인 쿼리 플랜이 된다.

**OR 쿼리**

몽고DB는 쿼리당 하나의 인덱스만 사용할 수 있다. 유일한 예외는 “$or”이다. “$or”은 두 개의 쿼리를 수행하고 결과를 합치므로 “$or”절 마다 하나씩 인덱스를 사용할 수 있다.

일반적으로 두 번 쿼리해서 결과를 병합하면 한 번 쿼리할 때보다 훨씬 비효율적이니 “$in”을 사용하자.

“$in” 쿼리를 실행할 때, 정렬을 제외하면 반환되는 도큐먼트의 순서를 제어하는 방법은 없다.

### 5.1.6 객체 및 배열 인데싱

**내장 도큐먼트 인덱싱하기**

인덱스는 일반적인 키에 생성될 때와 동일한 방식으로 내장 도큐먼트 키에 생성될 수 있다.

```jsx
> db.users.createIndex({"loc.city" : 1})
```

내장 도큐먼트 자체(”loc”)를 인덱싱하면 내장 도큐먼트의 필드(”loc.city”)를 인덱싱 할 때와는 매우 다르게 동작한다. 서브 도큐먼트 전체를 인덱싱하면 서브 도큐먼트 전체에 쿼리할 때만 도움이 된다.

**배열 인덱싱하기**

```jsx
> db.blog.createIndex({"comments.date" : 1})
```

게시글 목록에서 가장 최근에 댓글이 달린 게시물을 찾을 때 이러한 방식을 쓸 수 있다.

“loc”처럼 배열 전체를 단일 개체처럼 인덱싱할 수는 없다. 배열 필드 인덱싱은 배열 자체가 아니라 배열의 각 요소를 인덱싱한다.

복합 인덱스를 구성할 때 하나의 키만 배열로 부터 가져올 수 있다. 여러개를 허용하면 n*m개의 인덱스 항목이 생기기 때문이다.

**다중키 인덱스가 미치는 영향**

도큐먼트가 배열 필드를 인덱스 키로 가지면 인덱스는 즉시 다중키 인덱스로 표시된다. explain()을 출력하면 “isMultiKey”필드가 true다. 인덱스는 한번 다중키로 표시되면 필드 내 배열을 포함하는 도큐먼트가 모두 제거되더라도 비다중키가 될 수 없다.

다중키 인덱스는 하나의 도큐먼트를 여러 개의 인덱스 항목이 가리킬 수 있으므로 결과를 반환하기 전에 몽고DB가 중복을 제거해야한다. 그래서 약간 느릴 수 있다.

### 5.1.7 인덱스 카디널리티

카디널리티는 컬렉션의 한 필드에 대해 고윳값이 얼마나 많은지 나타낸다.

일반적으로 카디널리티가 높을수록 인덱싱에 도움이 된다. 복합 인덱스에서 높은 카디널리티 키를 낮은 카디널리티 키보다 앞에 놓자.

## 5.2 explain 출력

explain은 쿼리에 대한 많은 정보를 제공하며, 느린 쿼리를 위한 중요한 진단 도구이다.

샤딩은 쿼리를 여러 서버에서 수행하므로 explain들의 집합체를 반환한다.

nReturned : 실제로 반환된 도큐먼트 개수

totalKeysExamined : 검색한 인덱스 항목 개수

totlaDocsExamined : 몽고DB가 디스크 내 실제 도큐먼트를 가리키는 인덱스 포인터를 따라간 횟수. 쿼리가 인덱스의 일부가 아닌 검색 조건을 포함하거나, 인덱스에 포함되지 않은 필드를 반환하도록 요청한다면 각 인덱스 항목이 가리키는 도큐먼트를 살펴봐야 한다.

nscannedObjects : 스캔한 도큐먼트 개수

executionTimeMillis : 서버가 요청을 받고 응답을 보낸 시점까지 걸린 시간. 몽고DB가 여러 개의 쿼리 플랜을 시도했다면 “executionTimeMillis”는 최고로 뽑힌 플랜이 아니라 모든 플랜이 실행되기까지 걸린 시간을 반영한다.

istMultiKey : false

stage : 몽고DB가 인덱스를 사용해 쿼리할 수 있었는지 여부. “COLSCAN”은 인덱스로 쿼리할 수 없어 컬렉션 스캔을 수행했음을 뜻한다.

needYields : 쓰기 요청을 처리하도록 쿼리가 양보한 횟수. 대기 중인 쓰시가 있다면 쿼리는 일시적으로 락을 해제하고 쓰기가 처리되게 한다.

indexBounds : 인덱스가 어떻게 사용됐는지 설명하며 탐색한 인덱스의 범위를 제공한다.

## 5.3 인덱스를 생성하지 않는 경우

인덱스는 데이터의 일부를 조회할 때 가장 효율적이며 인덱스가 없는 게 더 빠른 경우도 있다. 인덱스는 컬렉션에서 가져와야 하는 부분이 많을수록 비효율적인데, 인덱스를 하나 사용하려면 두 번의 조회를 해야하기 때문이다.

한 번은 인덱스 항목을 살펴보고, 또 한 번은 도큐먼트를 가리키는 인덱스 포인터를 따라간다.

## 5.4 인덱스 종류

### 5.4.1 고유 인덱스

고유 인덱스는 각 값이 인덱스에 한 번 이하 나타나도록 보장한다.

**복합 고유 인덱스**

개별 키는 같은 값을 가질 수 있지만 인덱스 항목의 키 조합은 인덱스에서 최대 한 번만 나타난다.

### 5.4.2 부분 인덱스

부분 인덱스는 지정된 필터 표현식을 충족하는 컬렉션의 문서만 인덱싱한다.

고유 인덱스는 null을 값으로 취급하므로, 키가 없는 도큐먼트가 여러 개인 고유 인덱스를 만들 수 없다.

하지만 오직 키가 존재할 때만 고유 인덱스가 적용되도록 할 때가 많다. 고유한 필드가 존재하거나 필드가 아예 존재하지 않으면 “unique”와 “partial”을 결합할 수 있다.

부분 인덱스를 만들려면 “partialFilterExpression” 옵션을 포함시킨다.

예를 들어 이메일 주소는 선택 항목이지만 입력할 경우 고유해야 한다.

```jsx
> db.users.ensureIndex({"email" : 1}, {"unique" : true, "partialFilterExpression" : 
... {email : { $exists: true}}})
```

부분 인덱스는 반드시 고유할 필요는 없다. 고유하지 않은 부분 인덱스를 만드려면 “unique” 옵션을 제외 시키기만 하면 된다.

위의 예시에서 email로 조회를 하면 email이 없는 데이터는 조회되지 않는다.

## 5.5 인덱스 관리

데이터베이스의 인덱스 정보는 모두 system.indexes 컬렉션에 저장된다.

특정 컬렉션의 모든 인덱스 정보를 확인하려면 db.컬렉션명.getIndexes()를 실행한다.

### 5.5.1 인덱스 식별

컬렉션 내 각 인덱스는 고유하게 식별하는 이름이 있다. 인덱스명은 서버에서 인덱스를 삭제하거나 조작하는 데 사용된다. 인덱스명은 기본적으로 키이름1-방향1-키이름2-방향2…로 설정된다. createIndex 옵션으로 이름을 지정할 수 있다.

```jsx
> db.soup.createIndex({"a" : 1, "b" : 1, "c" : 1, ...},
... {"name" : "alphabet"})
```

### 5.5.2 인덱스 변경

dropIndex 명령어를 사용해 불필요한 인덱스를 제거할 수 있다.

```jsx
> db.people.dropIndex("x_1_y_1")
```

새로운 인덱스를 생성할 때는 읽기와 쓰기가 모두 멈춘다.

데이터베이스가 읽기와 쓰기에 어느정도 응답하려면 background 옵션을 사용할 수 있지만 foregorund 에서 진행하는 것 보다 훨씬 느리다. 몽고DB 4.2부터는 인덱스 구축 프로세스의 시작과 끝에만 락을 가진다.

## 6장 특수 인덱스와 컬렉션 유형

## 6.1 공간 정보 인덱스

## 6.2 전문 검색을 위한 인덱스

몽고DB의 text 인덱스는 전문 검색의 요구사항을 지원한다.

text 인덱스는 텍스트를 빠르게 검색하는 기능을 제공하며, 언어에 적합한 토큰화, 정지 단어, 형태소 분석 등 일반적인 검색 엔진 요구 사항을 지원한다.

컬렉션에 쓰기 작업을 수행하려면 모든 인덱스를 갱신해야 한다. 텍스트 검색을 사용하면 문자열이 토큰화되고, 형태소화되며, 인덱스는 잠재적으로 여러 위치에서 갱신된다. 따라서 쓰기 비용이 크다.

### 6.2.1 텍스트 인덱스 생성

```jsx
> db.articles.createIndex({"title" : "text", "body" : "text"})
```

가중치를 지정하면 각 필드에 지정하는 상대적 중요도를 제어할 수 있다.

```jsx
> db.articles.createIndex({"title" : "text", "body" : "text"},
{"weights" : {"title" : 3, "body" : 2}})
```

“$**” 키에 인덱스를 만들면 모든 문자열 필드에 전문 인덱스를 생성할 수 있다.

### 6.2.2 텍스트 검색

“$text” 쿼리 연산자를 사용하면 text 인덱스가 있는 컬렉션에 텍스트 검색을 할 수 있다.

```jsx
> db.articles.find({"$text" : {"$search" : "impact crater lunar"}}).limit(10)
```

위의 조회 방식은 두가지 문제가 있다. 각각의 단어를 or 검색하고 검색 결과를 관련성에 따라 정렬하지 않는다.

“\”impact crator\”  lunar” 로 조회를 하면 “impact crator” AND “lunar”로 처리를 한다.

“\”impact crator\”  \”lunar\” \”meteor\” 로 조회하면 “impact crator” AND “ lunar” AND “meteor”로 조회를 한다.

텍스트 쿼리를 사용하면 각 쿼리 결과에 메타데이터가 연결된다. 메타데이터는 $meta연산자를 사용해 명시적으로 투영하지 않으면 쿼리 결과에 표시되지 않는다.

```jsx
> db.articles.find(
  { $text: { $search: "\"impact crater\" lunar" } },
  { title: 1, score: { $meta: "textScore" } }
).sort({score: {"$meta" : "textScore"}}).limit(10)
```

### 6.2.3 전문 검색 최적화

전문 검색을 최적화하는 방법은 두가지다. 다른 기준으로 검색 결과를 좁힐 수 있다면 복합 인덱스를 생성할 때 다른 기준을 앞에 둔다.

또한 다른 기준을 뒤쪽에 두어 사용할 수도 있다.

### 6.2.4 다른 언어로 검색하기

도큐먼트를 입력할 때 “default_language” 로 언어를 지정할수도 있고, 데이터를 삽입할 때 “language 필드에 명시해 도큐먼트별로 형태소 분석 언어를 다르게 지정할 수 있다.

## 6.3 제한 컬렉션

제한 컬렉션은 미리 생성되어 크기가 고정된다.

이미 가득찬 제한 컬렉션에 입력을 시도하면 환형 큐처럼 동작하여 가장 오래된 다큐먼트가 지워지고 새로운 도큐먼트가 그 자리를 차지한다. 도큐먼트는 삭제할 수 없고, 크기가 커지도록 갱신도 허용되지 않는다.

일반적으로 몽고DB TTL 인덱스는 와이어드타이거 스토리지 엔진에서 더 나은 성능을 발휘하므로 제한 컬렉션 보다 권장된다. 제한 컬렉션은 샤딩될 수 없다.

제한 컬렉션은 유연성이 부족하지만 로깅에는 나름 유용하다.

### 6.3.1 제한 컬렉션 생성

일반 컬렉션과 달리 제한 컬렉션은 사용되기 전에 명시적으로 생성돼야 한다.

```jsx
> db.createCollection("my_collection", {"capped" : true, "size" : 100000, 
"max" : 100});
```

10만 바이트 고정 크기와 최대 개수 100을 가진 제한 컬렉션 my_collection을 만든다.

### 6.3.2 꼬리를 무는 커서

꼬리를 무는 커서는 결과를 모두 꺼낸 후에도 종료되지 않는 특수한 형태의 커서로 tail -f 명령어에서 영감을 받아 만들어졌다. 스트림 변경이 꼬리를 무는 커서보다 훨씬 많은 제어와 구성을 제공하여 대부분의 경우에 더 권장된다.

## 6.4 TTL 인덱스

오래된 순 삭제 시스템을 더 유연하게 만들려면 TTL 인덱스를 이용해서 각 도큐먼트에 유효 기간을 설정할 수 있다. 이런 인덱스는 세션 스토리지와 같은 문제를 캐싱하는데 유용하다.

```jsx
> db.sessions.createIndex({"lastUpdated" : 1}, {"expireAfterSeconds" : 60*60*24})
```

“lastUpdated” 필드에 TTL 인덱스를 생성한다. “expiredAfterSeconds”초가 지나면 도큐먼트가 삭제된다.

몽고DB는 인덱스를 매분마다 청소한다.

collMod 명령어를 이용해 “expiredAfterSeconds”를 변경할 수 있다.

하나의 컬렉션에 TTL 인덱스를 여러 개 가질 수 있다.

## 6.5 GridFS로 파일 저장하기

GridFS는 몽고DB에 대용량 이진 파일을 저장하는 매커니즘이다.